---
# Source: jupyterhub/templates/hub/netpol.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  podSelector:
    matchLabels:
      component: hub
      app: jupyterhub
      release: jupyterhub
  policyTypes:
    - Ingress
    - Egress

  # IMPORTANT:
  # NetworkPolicy's ingress "from" and egress "to" rule specifications require
  # great attention to detail. A quick summary is:
  #
  # 1. You can provide "from"/"to" rules that provide access either ports or a
  #    subset of ports.
  # 2. You can for each "from"/"to" rule provide any number of
  #    "sources"/"destinations" of four different kinds.
  #    - podSelector                        - targets pods with a certain label in the same namespace as the NetworkPolicy
  #    - namespaceSelector                  - targets all pods running in namespaces with a certain label
  #    - namespaceSelector and podSelector  - targets pods with a certain label running in namespaces with a certain label
  #    - ipBlock                            - targets network traffic from/to a set of IP address ranges
  #
  # Read more at: https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors
  #
  ingress:

    # allowed pods (hub.jupyter.org/network-access-hub) --> hub
    - ports:
        - port: http
      from:
        # source 1 - labeled pods
        - podSelector:
            matchLabels:
              hub.jupyter.org/network-access-hub: "true"

  egress:
    # hub --> proxy
    - to:
        - podSelector:
            matchLabels:
              component: proxy
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8001

    # hub --> singleuser-server
    - to:
        - podSelector:
            matchLabels:
              component: singleuser-server
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8888
    
    # Allow outbound connections to the DNS port in the private IP ranges
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
      to:
        - ipBlock:
            cidr: 10.0.0.0/8
        - ipBlock:
            cidr: 172.16.0.0/12
        - ipBlock:
            cidr: 192.168.0.0/16
    # Allow outbound connections to non-private IP ranges
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
              # As part of this rule, don't:
              # - allow outbound connections to private IP
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
              # - allow outbound connections to the cloud metadata server
              - 169.254.169.254/32
    # Allow outbound connections to private IP ranges
    - to:
        - ipBlock:
            cidr: 10.0.0.0/8
        - ipBlock:
            cidr: 172.16.0.0/12
        - ipBlock:
            cidr: 192.168.0.0/16
    # Allow outbound connections to the cloud metadata server
    - to:
        - ipBlock:
            cidr: 169.254.169.254/32
---
# Source: jupyterhub/templates/proxy/netpol.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: proxy
  labels:
    component: proxy
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  podSelector:
    matchLabels:
      component: proxy
      app: jupyterhub
      release: jupyterhub
  policyTypes:
    - Ingress
    - Egress

  # IMPORTANT:
  # NetworkPolicy's ingress "from" and egress "to" rule specifications require
  # great attention to detail. A quick summary is:
  #
  # 1. You can provide "from"/"to" rules that provide access either ports or a
  #    subset of ports.
  # 2. You can for each "from"/"to" rule provide any number of
  #    "sources"/"destinations" of four different kinds.
  #    - podSelector                        - targets pods with a certain label in the same namespace as the NetworkPolicy
  #    - namespaceSelector                  - targets all pods running in namespaces with a certain label
  #    - namespaceSelector and podSelector  - targets pods with a certain label running in namespaces with a certain label
  #    - ipBlock                            - targets network traffic from/to a set of IP address ranges
  #
  # Read more at: https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors
  #
  ingress:
    # allow incoming traffic to these ports independent of source
    - ports:
      - port: http
      - port: https

    # allowed pods (hub.jupyter.org/network-access-proxy-http) --> proxy (http/https port)
    - ports:
        - port: http
      from:
        # source 1 - labeled pods
        - podSelector:
            matchLabels:
              hub.jupyter.org/network-access-proxy-http: "true"

    # allowed pods (hub.jupyter.org/network-access-proxy-api) --> proxy (api port)
    - ports:
        - port: api
      from:
        # source 1 - labeled pods
        - podSelector:
            matchLabels:
              hub.jupyter.org/network-access-proxy-api: "true"

  egress:
    # proxy --> hub
    - to:
        - podSelector:
            matchLabels:
              component: hub
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8081

    # proxy --> singleuser-server
    - to:
        - podSelector:
            matchLabels:
              component: singleuser-server
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8888
    
    # Allow outbound connections to the DNS port in the private IP ranges
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
      to:
        - ipBlock:
            cidr: 10.0.0.0/8
        - ipBlock:
            cidr: 172.16.0.0/12
        - ipBlock:
            cidr: 192.168.0.0/16
    # Allow outbound connections to non-private IP ranges
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
              # As part of this rule, don't:
              # - allow outbound connections to private IP
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
              # - allow outbound connections to the cloud metadata server
              - 169.254.169.254/32
    # Allow outbound connections to private IP ranges
    - to:
        - ipBlock:
            cidr: 10.0.0.0/8
        - ipBlock:
            cidr: 172.16.0.0/12
        - ipBlock:
            cidr: 192.168.0.0/16
    # Allow outbound connections to the cloud metadata server
    - to:
        - ipBlock:
            cidr: 169.254.169.254/32
---
# Source: jupyterhub/templates/singleuser/netpol.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: singleuser
  labels:
    component: singleuser
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  podSelector:
    matchLabels:
      component: singleuser-server
      app: jupyterhub
      release: jupyterhub
  policyTypes:
    - Ingress
    - Egress

  # IMPORTANT:
  # NetworkPolicy's ingress "from" and egress "to" rule specifications require
  # great attention to detail. A quick summary is:
  #
  # 1. You can provide "from"/"to" rules that provide access either ports or a
  #    subset of ports.
  # 2. You can for each "from"/"to" rule provide any number of
  #    "sources"/"destinations" of four different kinds.
  #    - podSelector                        - targets pods with a certain label in the same namespace as the NetworkPolicy
  #    - namespaceSelector                  - targets all pods running in namespaces with a certain label
  #    - namespaceSelector and podSelector  - targets pods with a certain label running in namespaces with a certain label
  #    - ipBlock                            - targets network traffic from/to a set of IP address ranges
  #
  # Read more at: https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors
  #
  ingress:

    # allowed pods (hub.jupyter.org/network-access-singleuser) --> singleuser-server
    - ports:
        - port: notebook-port
      from:
        # source 1 - labeled pods
        - podSelector:
            matchLabels:
              hub.jupyter.org/network-access-singleuser: "true"

  egress:
    # singleuser-server --> hub
    - to:
        - podSelector:
            matchLabels:
              component: hub
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8081

    # singleuser-server --> proxy
    # singleuser-server --> autohttps
    #
    # While not critical for core functionality, a user or library code may rely
    # on communicating with the proxy or autohttps pods via a k8s Service it can
    # detected from well known environment variables.
    #
    - to:
        - podSelector:
            matchLabels:
              component: proxy
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8000
    - to:
        - podSelector:
            matchLabels:
              component: autohttps
              app: jupyterhub
              release: jupyterhub
      ports:
        - port: 8080
        - port: 8443
    
    # Allow outbound connections to the DNS port in the private IP ranges
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
      to:
        - ipBlock:
            cidr: 10.0.0.0/8
        - ipBlock:
            cidr: 172.16.0.0/12
        - ipBlock:
            cidr: 192.168.0.0/16
    # Allow outbound connections to non-private IP ranges
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
              # As part of this rule, don't:
              # - allow outbound connections to private IP
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
              # - allow outbound connections to the cloud metadata server
              - 169.254.169.254/32
---
# Source: jupyterhub/templates/scheduling/user-placeholder/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: user-placeholder
  labels:
    component: user-placeholder
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  minAvailable: 0
  selector:
    matchLabels:
      component: user-placeholder
      app: jupyterhub
      release: jupyterhub
---
# Source: jupyterhub/templates/scheduling/user-scheduler/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      component: user-scheduler
      app: jupyterhub
      release: jupyterhub
---
# Source: jupyterhub/templates/hub/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
---
# Source: jupyterhub/templates/scheduling/user-scheduler/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
---
# Source: jupyterhub/templates/hub/secret.yaml
kind: Secret
apiVersion: v1
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
type: Opaque
data:
  values.yaml: "Q2hhcnQ6CiAgTmFtZToganVweXRlcmh1YgogIFZlcnNpb246IDMuMC4wLTAuZGV2LmdpdC42MTcxLmgwZjRiMmQwYgpSZWxlYXNlOgogIE5hbWU6IGp1cHl0ZXJodWIKICBOYW1lc3BhY2U6IGp1cHl0ZXJodWIKICBTZXJ2aWNlOiBIZWxtCmN1bGw6CiAgYWRtaW5Vc2VyczogdHJ1ZQogIGNvbmN1cnJlbmN5OiAxMAogIGVuYWJsZWQ6IHRydWUKICBldmVyeTogNjAwCiAgbWF4QWdlOiAwCiAgcmVtb3ZlTmFtZWRTZXJ2ZXJzOiBmYWxzZQogIHRpbWVvdXQ6IDM2MDAKICB1c2VyczogZmFsc2UKY3VzdG9tOiB7fQpkZWJ1ZzoKICBlbmFibGVkOiBmYWxzZQpmdWxsbmFtZU92ZXJyaWRlOiAiIgpnbG9iYWw6CiAgc2FmZVRvU2hvd1ZhbHVlczogZmFsc2UKaHViOgogIGFjdGl2ZVNlcnZlckxpbWl0OiBudWxsCiAgYWxsb3dOYW1lZFNlcnZlcnM6IGZhbHNlCiAgYW5ub3RhdGlvbnM6IHt9CiAgYXJnczogW10KICBhdXRoZW50aWNhdGVQcm9tZXRoZXVzOiBudWxsCiAgYmFzZVVybDogLwogIGNvbW1hbmQ6IFtdCiAgY29uY3VycmVudFNwYXduTGltaXQ6IDY0CiAgY29uZmlnOgogICAgSnVweXRlckh1YjoKICAgICAgYWRtaW5fYWNjZXNzOiB0cnVlCiAgICAgIGF1dGhlbnRpY2F0b3JfY2xhc3M6IGR1bW15CiAgY29uc2VjdXRpdmVGYWlsdXJlTGltaXQ6IDUKICBjb250YWluZXJTZWN1cml0eUNvbnRleHQ6CiAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICBydW5Bc0dyb3VwOiAxMDAwCiAgICBydW5Bc1VzZXI6IDEwMDAKICBjb29raWVTZWNyZXQ6IG51bGwKICBkYjoKICAgIHBhc3N3b3JkOiBudWxsCiAgICBwdmM6CiAgICAgIGFjY2Vzc01vZGVzOgogICAgICAtIFJlYWRXcml0ZU9uY2UKICAgICAgYW5ub3RhdGlvbnM6IHt9CiAgICAgIHNlbGVjdG9yOiB7fQogICAgICBzdG9yYWdlOiAxR2kKICAgICAgc3RvcmFnZUNsYXNzTmFtZTogbnVsbAogICAgICBzdWJQYXRoOiBudWxsCiAgICB0eXBlOiBzcWxpdGUtcHZjCiAgICB1cGdyYWRlOiBudWxsCiAgICB1cmw6IG51bGwKICBkZXBsb3ltZW50U3RyYXRlZ3k6CiAgICB0eXBlOiBSZWNyZWF0ZQogIGV4aXN0aW5nU2VjcmV0OiBudWxsCiAgZXh0cmFDb25maWc6CiAgICAwMF9iaW5kX3VybF9jb25maWc6ICIiCiAgZXh0cmFDb250YWluZXJzOiBbXQogIGV4dHJhRW52OgogICAgT0FVVEhfQ0xJRU5UX0lEOgogICAgICB2YWx1ZUZyb206CiAgICAgICAgc2VjcmV0S2V5UmVmOgogICAgICAgICAga2V5OiBPQVVUSF9DTElFTlRfSUQKICAgICAgICAgIG5hbWU6IGp1cHl0ZXJodWItb2F1dGgta2V5Y2xvYWsKICAgIE9BVVRIX0NMSUVOVF9TRUNSRVQ6CiAgICAgIHZhbHVlRnJvbToKICAgICAgICBzZWNyZXRLZXlSZWY6CiAgICAgICAgICBrZXk6IE9BVVRIX0NMSUVOVF9TRUNSRVQKICAgICAgICAgIG5hbWU6IGp1cHl0ZXJodWItb2F1dGgta2V5Y2xvYWsKICAgIE9BVVRIX0xPR09VVF9SRURJUkVDVF9VUkw6CiAgICAgIHZhbHVlRnJvbToKICAgICAgICBzZWNyZXRLZXlSZWY6CiAgICAgICAgICBrZXk6IE9BVVRIX0xPR09VVF9SRURJUkVDVF9VUkwKICAgICAgICAgIG5hbWU6IGp1cHl0ZXJodWItb2F1dGgta2V5Y2xvYWsKICAgIE9BVVRIMl9BVVRIT1JJWkVfVVJMOgogICAgICB2YWx1ZUZyb206CiAgICAgICAgc2VjcmV0S2V5UmVmOgogICAgICAgICAga2V5OiBPQVVUSDJfQVVUSE9SSVpFX1VSTAogICAgICAgICAgbmFtZToganVweXRlcmh1Yi1vYXV0aC1rZXljbG9hawogICAgT0FVVEgyX1RPS0VOX1VSTDoKICAgICAgdmFsdWVGcm9tOgogICAgICAgIHNlY3JldEtleVJlZjoKICAgICAgICAgIGtleTogT0FVVEgyX1RPS0VOX1VSTAogICAgICAgICAgbmFtZToganVweXRlcmh1Yi1vYXV0aC1rZXljbG9hawogICAgT0FVVEgyX1VTRVJEQVRBX1VSTDoKICAgICAgdmFsdWVGcm9tOgogICAgICAgIHNlY3JldEtleVJlZjoKICAgICAgICAgIGtleTogT0FVVEgyX1VTRVJEQVRBX1VSTAogICAgICAgICAgbmFtZToganVweXRlcmh1Yi1vYXV0aC1rZXljbG9hawogICAgUFlUSE9OUEFUSDogL2FwcC9jdXN0b206JChQWVRIT05QQVRIKQogIGV4dHJhRmlsZXM6CiAgICBiaW5kX3VybF9jb25maWc6CiAgICAgIG1vdW50UGF0aDogL3Vzci9sb2NhbC9ldGMvanVweXRlcmh1Yi9qdXB5dGVyaHViX2NvbmZpZy5kLzAwX2JpbmRfdXJsX2NvbmZpZy5weQogICAgICBzdHJpbmdEYXRhOiB8CiAgICAgICAgYy5KdXB5dGVySHViLmJpbmRfdXJsID0gJ2h0dHBzOi8vanVweXRlcmh1Yi5wcm9kLms4cy44NmxhYnMuY29tJwogICAgICAgIGMuSnVweXRlckh1Yi5hZG1pbl9hY2Nlc3MgPSBUcnVlCiAgICBjdXN0b21fa3ViZV9zcGF3bmVyOgogICAgICBtb3VudFBhdGg6IC9hcHAvY3VzdG9tL2N1c3RvbV9rdWJlX3NwYXduZXIucHkKICAgICAgc3RyaW5nRGF0YTogImltcG9ydCBqc29uXG5mcm9tIGt1YmVzcGF3bmVyIGltcG9ydCBLdWJlU3Bhd25lclxuZnJvbSBrdWJlcm5ldGVzX2FzeW5jaW8uY2xpZW50CiAgICAgICAgaW1wb3J0IG1vZGVscyBhcyBrOHNcblxuY2xhc3MgQ3VzdG9tS3ViZVNwYXduZXIoS3ViZVNwYXduZXIpOlxuICAgIGRlZiBhdXRoX3N0YXRlX2hvb2soc2VsZiwKICAgICAgICBzcGF3bmVyLCBhdXRoX3N0YXRlKTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIFRoaXMgdXNlciBob29rIGF0dGFjaGVzIHRoZQogICAgICAgIHVzZXIgaW5mb3JtYXRpb24gdG8gdGhlIHNwYXduZXIsXG4gICAgICAgIHdoaWNoIHdlIGNhbiB1c2Ugd2hlbiBnZW5lcmF0aW5nCiAgICAgICAgdGhlIHByb2ZpbGUgbGlzdC5cbiAgICAgICAgVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBrdWJlcm5ldGVzIG92ZXJyaWRlcyBiYXNlCiAgICAgICAgb24gT0F1dGgyIGF0dHJpYnV0ZXMuXG4gICAgICAgIFwiXCJcIlxuICAgICAgICB1c2VyaW5mbyA9IGF1dGhfc3RhdGUuZ2V0KFwib2F1dGhfdXNlclwiKVxuCiAgICAgICAgXCAgICAgICBzZWxmLmxvZy5pbmZvKGZcImdvdCB1c2VyIGluZm8ge3VzZXJpbmZvfVwiKVxuICAgICAgICBzcGF3bmVyLnVzZXJpbmZvCiAgICAgICAgPSB1c2VyaW5mb1xuXG4gICAgZGVmIHByb2ZpbGVfbGlzdChzZWxmLCBzcGF3bmVyKTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIFRoZQogICAgICAgIHByb2ZpbGUgbGlzdCBmb3IgdGhlIEt1YmVTcGF3bmVyIGNhbiBiZSBhIGNhbGxhYmxlIGZyb20gdGhlIFNwYXduZXIgb2JqZWN0XG4KICAgICAgICBcICAgICAgIEFsbG93aW5nIHVzIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlIHByb2ZpbGVzIGJhc2VkIG9uIHRoZSB1c2VyIGluZm9cbgogICAgICAgIFwgICAgICAgXCJcIlwiXG4gICAgICAgIHVzZXJfaW5mbyA9IHNwYXduZXIudXNlcmluZm9cbiAgICAgICAgaW1hZ2Vfb3B0aW9ucwogICAgICAgID0ge1wiZGlzcGxheV9uYW1lXCI6IFwiSW1hZ2VcIiwgXCJjaG9pY2VzXCI6IHtcImN1c3RvbVwiOiB7XCJkaXNwbGF5X25hbWVcIjoKICAgICAgICBcIkN1c3RvbSBTaW5nbGUgU2VydmVyXCIsIFwia3ViZXNwYXduZXJfb3ZlcnJpZGVcIjoge1wiaW1hZ2VcIjogXCJnZmVsZG1hbjgvanVweXRlcmh1Yi1rOHMtc2luZ2xldXNlcjpsYXRlc3RcIn0KICAgICAgICB9ICwgXCJweXRvcmNoMlwiOiB7XCJkaXNwbGF5X25hbWVcIjogXCJQeXRob24gMyBUcmFpbmluZyBOb3RlYm9vayAyXCIsIFwia3ViZXNwYXduZXJfb3ZlcnJpZGVcIjoKICAgICAgICB7XCJpbWFnZVwiOiBcInRyYWluaW5nL3B5dGhvbjoyMDIyLjAxLjAxXCJ9IH0gfX1cbiAgICAgICAgcmV0dXJuIFt7J2Rpc3BsYXlfbmFtZSc6CiAgICAgICAgZidUcmFpbmluZyBFbnYgZm9yIHt1c2VyX2luZm8uZ2V0KFwibmFtZVwiKX0nLCAnc2x1Zyc6ICd0cmFpbmluZy1weXRob24nLAogICAgICAgICdkZWZhdWx0JzogVHJ1ZSwgXCJwcm9maWxlX29wdGlvbnNcIjoge1wiaW1hZ2VcIjogaW1hZ2Vfb3B0aW9uc30gfSwgeydkaXNwbGF5X25hbWUnOgogICAgICAgIGYnUHJvZCBFbnYgZm9yIHt1c2VyX2luZm8uZ2V0KFwibmFtZVwiKX0nLCdzbHVnJzogJ3Byb2QtcHl0aG9uJywnZGVmYXVsdCc6CiAgICAgICAgRmFsc2V9XVxuXG4gICAgZGVmIGdldF9lbnYoc2VsZik6XG4gICAgICAgIGVudiA9IHN1cGVyKCkuZ2V0X2VudigpXG4gICAgICAgIGlmCiAgICAgICAgaGFzYXR0cihzZWxmLCd1c2VyaW5mbycpOlxuICAgICAgICAgICAgZW52WydQUk9QX1VTRVJfSU5GTyddID0gc2VsZi51c2VyaW5mby5nZXQoXCJuYW1lXCIsCiAgICAgICAgXCJcIilcbiAgICAgICAgaWYgaGFzYXR0cihzZWxmLCAndXNlcl9vcHRpb25zJyk6XG4gICAgICAgICAgICBlbnZbJ1BST1BfVVNFUl9QUk9GSUxFJ10KICAgICAgICA9IHNlbGYudXNlcl9vcHRpb25zLmdldChcInByb2ZpbGVcIixcIlwiKVxuICAgICAgICBzZWxmLmxvZy5pbmZvKGZcIkdvdCBlbnZpcm9ubWVudAogICAgICAgIHZhcmlhYmxlcyB7ZW52fVwiKVxuICAgICAgICByZXR1cm4gZW52XG4gICAgXG4gICAgZGVmIGdldF9zZXJ2aWNlX2FjY291bnRfZnJvbV91c2VyX2luZm8oc2VsZiwKICAgICAgICBzcGF3bmVyKTpcbiAgICAgICAgdXNlcl9pbmZvID0gc3Bhd25lci51c2VyaW5mb1xuICAgICAgICBzZWxmLmxvZy5pbmZvKGZcImdvdAogICAgICAgIHVzZXIgaW5mbyBpbiBtb2RpZnlfcG9kX2hvb2sge3VzZXJfaW5mb31cIilcbiAgICAgICAgcmV0dXJuIFwianVweXRlcmh1Yi11c2VyXCJcbgogICAgICAgIFwgICBcbiAgICBkZWYgbW9kaWZ5X3BvZF9ob29rKHNlbGYsIHNwYXduZXIsIHBvZDogazhzLlYxUG9kKTpcbiAgICAgICAgIyBzZXQKICAgICAgICBzZXJ2aWNlIGFjY291bnQgYmFzZWQgb24gdXNlciBpbmZvXG4gICAgICAgIHBvZC5zcGVjLnNlcnZpY2VfYWNjb3VudCA9IHNlbGYuZ2V0X3NlcnZpY2VfYWNjb3VudF9mcm9tX3VzZXJfaW5mbyhzcGF3bmVyKVxuCiAgICAgICAgXCAgICAgICBwb2Quc3BlYy5zZXJ2aWNlX2FjY291bnRfbmFtZSA9IHNlbGYuZ2V0X3NlcnZpY2VfYWNjb3VudF9mcm9tX3VzZXJfaW5mbyhzcGF3bmVyKVxuCiAgICAgICAgXCAgICAgICBwb2Quc3BlYy5hdXRvbW91bnRfc2VydmljZV9hY2NvdW50X3Rva2VuID0gVHJ1ZVxuICAgICAgICAjIHNldCB1c2VyCiAgICAgICAgcm9vdCB0byByZWFkIG9ubHkgZmlsZSBzeXN0ZW0gc28gdGhleSBkbyBub3Qgc3RvcmUgZmlsZXMgdGhlcmUgcGVybWFuZW50bHlcbgogICAgICAgIFwgICAgICAgcG9kLnNwZWMudm9sdW1lcy5hcHBlbmQoazhzLlYxVm9sdW1lKG5hbWU9XCJqdXB5dGVyLXJvb3RcIixlbXB0eV9kaXI9azhzLlYxRW1wdHlEaXJWb2x1bWVTb3VyY2UoKSkpXG4KICAgICAgICBcICAgICAgIHBvZC5zcGVjLmNvbnRhaW5lcnNbMF0udm9sdW1lX21vdW50cy5hcHBlbmQoazhzLlYxVm9sdW1lTW91bnQobmFtZT1cImp1cHl0ZXItcm9vdFwiLAogICAgICAgIG1vdW50X3BhdGg9XCIvdG1wL2NvbnRhaW5lclwiLHJlYWRfb25seT1GYWxzZSkpXG4gICAgICAgIHBvZC5zcGVjLmNvbnRhaW5lcnNbMF0uaW1hZ2VfcHVsbF9wb2xpY3kKICAgICAgICA9IFwiQWx3YXlzXCJcbiAgICAgICAgc2VsZi5sb2cuaW5mbyhmXCJnb3QgcG9kIGluIG1vZGlmeV9wb2RfaG9vayB7cG9kfVwiKVxuCiAgICAgICAgXCAgICAgICByZXR1cm4gcG9kIgogICAga2V5Y2xvYWtfYXV0aGVudGljYXRvcjoKICAgICAgbW91bnRQYXRoOiAvYXBwL2N1c3RvbS9rZXljbG9ha19hdXRoZW50aWNhdG9yLnB5CiAgICAgIHN0cmluZ0RhdGE6ICJmcm9tIG9hdXRoZW50aWNhdG9yLmdlbmVyaWMgaW1wb3J0IEdlbmVyaWNPQXV0aGVudGljYXRvclxuIyBzdWJjbGFzc2luZwogICAgICAgIHRoZSBHZW5lcmljT0F1dGhlbnRpY2F0b3IgaW4gY2FzZSB3ZSBuZWVkIHRvIFxuIyBlbnJpY2ggdGhlIHVzZXIgaW5mb1xuIyBodHRwczovL2dpdGh1Yi5jb20vanVweXRlcmh1Yi9vYXV0aGVudGljYXRvci9ibG9iL21haW4vb2F1dGhlbnRpY2F0b3IvZ2VuZXJpYy5weVxuXG5jbGFzcwogICAgICAgIEtleWNsb2FrQXV0aGVudGljYXRvcihHZW5lcmljT0F1dGhlbnRpY2F0b3IpOlxuICAgIGxvZ2luX3NlcnZpY2UgPSAna2V5Y2xvYWsnXG4KICAgICAgICBcICAgdXNlcmRhdGFfcGFyYW1zID0ge1wic3RhdGVcIjogXCJzdGF0ZVwifVxuICAgIHVzZXJuYW1lX2tleSA9ICBcInByZWZlcnJlZF91c2VybmFtZVwiXG4KICAgICAgICBcICAgYWRtaW5fZ3JvdXBzID0gW1wianVweXRlcmh1Yi1hZG1pblwiXVxuICAgIGFsbG93ZWRfZ3JvdXBzID0gW1wianVweXRlcmh1Yi11c2VyXCIsCiAgICAgICAgXCJqdXB5dGVyaHViLWFkbWluXCJdXG4gICAgZW5hYmxlX2F1dGhfc3RhdGUgPSAgVHJ1ZVxuXG4gICAgZGVmIGNsYWltX2dyb3Vwc19rZXkoc2VsZiwKICAgICAgICB1c2VyaW5mb19kYXRhKTpcbiAgICAgICAgcmV0dXJuIHVzZXJpbmZvX2RhdGFbJ2p1cHl0ZXJodWJfZ3JvdXBzJ11cblxuICAgIFxuIgogICAga2V5Y2xvYWtfY29uZmlnOgogICAgICBtb3VudFBhdGg6IC91c3IvbG9jYWwvZXRjL2p1cHl0ZXJodWIvanVweXRlcmh1Yl9jb25maWcuZC8wMV9rZXljbG9ha19jb25maWcucHkKICAgICAgc3RyaW5nRGF0YTogfAogICAgICAgIGZyb20ga2V5Y2xvYWtfYXV0aGVudGljYXRvciBpbXBvcnQgS2V5Y2xvYWtBdXRoZW50aWNhdG9yCiAgICAgICAgYy5KdXB5dGVySHViLmF1dGhlbnRpY2F0b3JfY2xhc3MgPSBLZXljbG9ha0F1dGhlbnRpY2F0b3IKICAgIHNwYXduZXJfY29uZmlnOgogICAgICBtb3VudFBhdGg6IC91c3IvbG9jYWwvZXRjL2p1cHl0ZXJodWIvanVweXRlcmh1Yl9jb25maWcuZC8wMl9zcGF3bmVyX2NvbmZpZy5weQogICAgICBzdHJpbmdEYXRhOiB8CiAgICAgICAgZnJvbSBjdXN0b21fa3ViZV9zcGF3bmVyIGltcG9ydCBDdXN0b21LdWJlU3Bhd25lcgogICAgICAgIGMuSnVweXRlckh1Yi5zcGF3bmVyX2NsYXNzID0gQ3VzdG9tS3ViZVNwYXduZXIKICBleHRyYVBvZFNwZWM6IHt9CiAgZXh0cmFWb2x1bWVNb3VudHM6IFtdCiAgZXh0cmFWb2x1bWVzOiBbXQogIGltYWdlOgogICAgbmFtZToganVweXRlcmh1Yi9rOHMtaHViCiAgICBwdWxsUG9saWN5OiBudWxsCiAgICBwdWxsU2VjcmV0czogW10KICAgIHRhZzogMy4wLjAtMC5kZXYuZ2l0LjYxNjcuaDQzYWYxYzU1CiAgaW5pdENvbnRhaW5lcnM6IFtdCiAgbGFiZWxzOiB7fQogIGxpZmVjeWNsZToge30KICBsaXZlbmVzc1Byb2JlOgogICAgZW5hYmxlZDogdHJ1ZQogICAgZmFpbHVyZVRocmVzaG9sZDogMzAKICAgIGluaXRpYWxEZWxheVNlY29uZHM6IDMwMAogICAgcGVyaW9kU2Vjb25kczogMTAKICAgIHRpbWVvdXRTZWNvbmRzOiAzCiAgbG9hZFJvbGVzOiB7fQogIG5hbWVkU2VydmVyTGltaXRQZXJVc2VyOiBudWxsCiAgbmV0d29ya1BvbGljeToKICAgIGFsbG93ZWRJbmdyZXNzUG9ydHM6IFtdCiAgICBlZ3Jlc3M6IFtdCiAgICBlZ3Jlc3NBbGxvd1J1bGVzOgogICAgICBjbG91ZE1ldGFkYXRhU2VydmVyOiB0cnVlCiAgICAgIGRuc1BvcnRzUHJpdmF0ZUlQczogdHJ1ZQogICAgICBub25Qcml2YXRlSVBzOiB0cnVlCiAgICAgIHByaXZhdGVJUHM6IHRydWUKICAgIGVuYWJsZWQ6IHRydWUKICAgIGluZ3Jlc3M6IFtdCiAgICBpbnRlck5hbWVzcGFjZUFjY2Vzc0xhYmVsczogaWdub3JlCiAgbm9kZVNlbGVjdG9yOiB7fQogIHBkYjoKICAgIGVuYWJsZWQ6IGZhbHNlCiAgICBtYXhVbmF2YWlsYWJsZTogbnVsbAogICAgbWluQXZhaWxhYmxlOiAxCiAgcG9kU2VjdXJpdHlDb250ZXh0OgogICAgZnNHcm91cDogMTAwMAogIHJlYWRpbmVzc1Byb2JlOgogICAgZW5hYmxlZDogdHJ1ZQogICAgZmFpbHVyZVRocmVzaG9sZDogMTAwMAogICAgaW5pdGlhbERlbGF5U2Vjb25kczogMAogICAgcGVyaW9kU2Vjb25kczogMgogICAgdGltZW91dFNlY29uZHM6IDEKICByZWRpcmVjdFRvU2VydmVyOiBudWxsCiAgcmVzb3VyY2VzOiB7fQogIHJldmlzaW9uSGlzdG9yeUxpbWl0OiBudWxsCiAgc2VydmljZToKICAgIGFubm90YXRpb25zOiB7fQogICAgZXh0cmFQb3J0czogW10KICAgIGxvYWRCYWxhbmNlcklQOiBudWxsCiAgICBwb3J0czoKICAgICAgbm9kZVBvcnQ6IG51bGwKICAgIHR5cGU6IENsdXN0ZXJJUAogIHNlcnZpY2VBY2NvdW50OgogICAgYW5ub3RhdGlvbnM6IHt9CiAgICBjcmVhdGU6IHRydWUKICAgIG5hbWU6IG51bGwKICBzZXJ2aWNlczoge30KICBzaHV0ZG93bk9uTG9nb3V0OiBudWxsCiAgdGVtcGxhdGVQYXRoczogW10KICB0ZW1wbGF0ZVZhcnM6IHt9CiAgdG9sZXJhdGlvbnM6IFtdCmltYWdlUHVsbFNlY3JldDoKICBhdXRvbWF0aWNSZWZlcmVuY2VJbmplY3Rpb246IHRydWUKICBjcmVhdGU6IGZhbHNlCiAgZW1haWw6IG51bGwKICBwYXNzd29yZDogbnVsbAogIHJlZ2lzdHJ5OiBudWxsCiAgdXNlcm5hbWU6IG51bGwKaW1hZ2VQdWxsU2VjcmV0czogW10KaW5ncmVzczoKICBhbm5vdGF0aW9uczoKICAgIGNlcnQtbWFuYWdlci5pby9jbHVzdGVyLWlzc3VlcjogbGV0c2VuY3J5cHQtcHJvZAogICAgbmdpbnguaW5ncmVzcy5rdWJlcm5ldGVzLmlvL2JhY2tlbmQtcHJvdG9jb2w6IEhUVFAKICAgIG5naW54LmluZ3Jlc3Mua3ViZXJuZXRlcy5pby9mb3JjZS1zc2wtcmVkaXJlY3Q6ICJ0cnVlIgogIGVuYWJsZWQ6IHRydWUKICBob3N0czoKICAtIGp1cHl0ZXJodWIucHJvZC5rOHMuODZsYWJzLmNvbQogIGluZ3Jlc3NDbGFzc05hbWU6IG5naW54CiAgcGF0aFN1ZmZpeDogbnVsbAogIHBhdGhUeXBlOiBQcmVmaXgKICB0bHM6CiAgLSBob3N0czoKICAgIC0ganVweXRlcmh1Yi5wcm9kLms4cy44NmxhYnMuY29tCiAgICBzZWNyZXROYW1lOiBqdXB5dGVyaHViLXByb2QtazhzLTg2bGFicy1jb20KcHJlUHVsbGVyOgogIGFubm90YXRpb25zOiB7fQogIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgIGFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbjogZmFsc2UKICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICBydW5Bc1VzZXI6IDY1NTM0CiAgY29udGludW91czoKICAgIGVuYWJsZWQ6IHRydWUKICBleHRyYUltYWdlczoge30KICBleHRyYVRvbGVyYXRpb25zOiBbXQogIGhvb2s6CiAgICBjb250YWluZXJTZWN1cml0eUNvbnRleHQ6CiAgICAgIGFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbjogZmFsc2UKICAgICAgcnVuQXNHcm91cDogNjU1MzQKICAgICAgcnVuQXNVc2VyOiA2NTUzNAogICAgZW5hYmxlZDogdHJ1ZQogICAgaW1hZ2U6CiAgICAgIG5hbWU6IGp1cHl0ZXJodWIvazhzLWltYWdlLWF3YWl0ZXIKICAgICAgcHVsbFBvbGljeTogbnVsbAogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiAzLjAuMC0wLmRldi5naXQuNjExNC5oYzBkMGIzYjAKICAgIG5vZGVTZWxlY3Rvcjoge30KICAgIHBvZFNjaGVkdWxpbmdXYWl0RHVyYXRpb246IDEwCiAgICBwdWxsT25seU9uQ2hhbmdlczogdHJ1ZQogICAgcmVzb3VyY2VzOiB7fQogICAgc2VydmljZUFjY291bnQ6CiAgICAgIGFubm90YXRpb25zOiB7fQogICAgICBjcmVhdGU6IHRydWUKICAgICAgbmFtZTogbnVsbAogICAgdG9sZXJhdGlvbnM6IFtdCiAgbGFiZWxzOiB7fQogIHBhdXNlOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGltYWdlOgogICAgICBuYW1lOiByZWdpc3RyeS5rOHMuaW8vcGF1c2UKICAgICAgcHVsbFBvbGljeTogbnVsbAogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiAiMy45IgogIHB1bGxQcm9maWxlTGlzdEltYWdlczogdHJ1ZQogIHJlc291cmNlczoge30KICByZXZpc2lvbkhpc3RvcnlMaW1pdDogbnVsbApwcm94eToKICBhbm5vdGF0aW9uczoge30KICBjaHA6CiAgICBjb250YWluZXJTZWN1cml0eUNvbnRleHQ6CiAgICAgIGFsbG93UHJpdmlsZWdlRXNjYWxhdGlvbjogZmFsc2UKICAgICAgcnVuQXNHcm91cDogNjU1MzQKICAgICAgcnVuQXNVc2VyOiA2NTUzNAogICAgZGVmYXVsdFRhcmdldDogbnVsbAogICAgZXJyb3JUYXJnZXQ6IG51bGwKICAgIGV4dHJhQ29tbWFuZExpbmVGbGFnczogW10KICAgIGV4dHJhRW52OiB7fQogICAgZXh0cmFQb2RTcGVjOiB7fQogICAgaW1hZ2U6CiAgICAgIG5hbWU6IGp1cHl0ZXJodWIvY29uZmlndXJhYmxlLWh0dHAtcHJveHkKICAgICAgcHVsbFBvbGljeTogbnVsbAogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiA0LjUuNQogICAgbGl2ZW5lc3NQcm9iZToKICAgICAgZW5hYmxlZDogdHJ1ZQogICAgICBmYWlsdXJlVGhyZXNob2xkOiAzMAogICAgICBpbml0aWFsRGVsYXlTZWNvbmRzOiA2MAogICAgICBwZXJpb2RTZWNvbmRzOiAxMAogICAgICB0aW1lb3V0U2Vjb25kczogMwogICAgbmV0d29ya1BvbGljeToKICAgICAgYWxsb3dlZEluZ3Jlc3NQb3J0czoKICAgICAgLSBodHRwCiAgICAgIC0gaHR0cHMKICAgICAgZWdyZXNzOiBbXQogICAgICBlZ3Jlc3NBbGxvd1J1bGVzOgogICAgICAgIGNsb3VkTWV0YWRhdGFTZXJ2ZXI6IHRydWUKICAgICAgICBkbnNQb3J0c1ByaXZhdGVJUHM6IHRydWUKICAgICAgICBub25Qcml2YXRlSVBzOiB0cnVlCiAgICAgICAgcHJpdmF0ZUlQczogdHJ1ZQogICAgICBlbmFibGVkOiB0cnVlCiAgICAgIGluZ3Jlc3M6IFtdCiAgICAgIGludGVyTmFtZXNwYWNlQWNjZXNzTGFiZWxzOiBpZ25vcmUKICAgIG5vZGVTZWxlY3Rvcjoge30KICAgIHBkYjoKICAgICAgZW5hYmxlZDogZmFsc2UKICAgICAgbWF4VW5hdmFpbGFibGU6IG51bGwKICAgICAgbWluQXZhaWxhYmxlOiAxCiAgICByZWFkaW5lc3NQcm9iZToKICAgICAgZW5hYmxlZDogdHJ1ZQogICAgICBmYWlsdXJlVGhyZXNob2xkOiAxMDAwCiAgICAgIGluaXRpYWxEZWxheVNlY29uZHM6IDAKICAgICAgcGVyaW9kU2Vjb25kczogMgogICAgICB0aW1lb3V0U2Vjb25kczogMQogICAgcmVzb3VyY2VzOiB7fQogICAgcmV2aXNpb25IaXN0b3J5TGltaXQ6IG51bGwKICAgIHRvbGVyYXRpb25zOiBbXQogIGRlcGxveW1lbnRTdHJhdGVneToKICAgIHJvbGxpbmdVcGRhdGU6IG51bGwKICAgIHR5cGU6IFJlY3JlYXRlCiAgaHR0cHM6CiAgICBlbmFibGVkOiB0cnVlCiAgICBob3N0czogW10KICAgIGxldHNlbmNyeXB0OgogICAgICBhY21lU2VydmVyOiBodHRwczovL2FjbWUtdjAyLmFwaS5sZXRzZW5jcnlwdC5vcmcvZGlyZWN0b3J5CiAgICAgIGNvbnRhY3RFbWFpbDogbnVsbAogICAgbWFudWFsOgogICAgICBjZXJ0OiBudWxsCiAgICAgIGtleTogbnVsbAogICAgc2VjcmV0OgogICAgICBjcnQ6IHRscy5jcnQKICAgICAga2V5OiB0bHMua2V5CiAgICAgIG5hbWU6IG51bGwKICAgIHR5cGU6IG9mZmxvYWQKICBsYWJlbHM6IHt9CiAgc2VjcmV0U3luYzoKICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBpbWFnZToKICAgICAgbmFtZToganVweXRlcmh1Yi9rOHMtc2VjcmV0LXN5bmMKICAgICAgcHVsbFBvbGljeTogbnVsbAogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiAzLjAuMC0wLmRldi5naXQuNjE3MS5oMGY0YjJkMGIKICAgIHJlc291cmNlczoge30KICBzZWNyZXRUb2tlbjogbnVsbAogIHNlcnZpY2U6CiAgICBhbm5vdGF0aW9uczoge30KICAgIGRpc2FibGVIdHRwUG9ydDogZmFsc2UKICAgIGV4dHJhUG9ydHM6IFtdCiAgICBsYWJlbHM6IHt9CiAgICBsb2FkQmFsYW5jZXJJUDogbnVsbAogICAgbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzOiBbXQogICAgbm9kZVBvcnRzOgogICAgICBodHRwOiBudWxsCiAgICAgIGh0dHBzOiBudWxsCiAgICB0eXBlOiBDbHVzdGVySVAKICB0cmFlZmlrOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGV4dHJhRHluYW1pY0NvbmZpZzoge30KICAgIGV4dHJhRW52OiB7fQogICAgZXh0cmFJbml0Q29udGFpbmVyczogW10KICAgIGV4dHJhUG9kU3BlYzoge30KICAgIGV4dHJhUG9ydHM6IFtdCiAgICBleHRyYVN0YXRpY0NvbmZpZzoge30KICAgIGV4dHJhVm9sdW1lTW91bnRzOiBbXQogICAgZXh0cmFWb2x1bWVzOiBbXQogICAgaHN0czoKICAgICAgaW5jbHVkZVN1YmRvbWFpbnM6IGZhbHNlCiAgICAgIG1heEFnZTogMTU3MjQ4MDAKICAgICAgcHJlbG9hZDogZmFsc2UKICAgIGltYWdlOgogICAgICBuYW1lOiB0cmFlZmlrCiAgICAgIHB1bGxQb2xpY3k6IG51bGwKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogdjIuMTAuMQogICAgbGFiZWxzOiB7fQogICAgbmV0d29ya1BvbGljeToKICAgICAgYWxsb3dlZEluZ3Jlc3NQb3J0czoKICAgICAgLSBodHRwCiAgICAgIC0gaHR0cHMKICAgICAgZWdyZXNzOiBbXQogICAgICBlZ3Jlc3NBbGxvd1J1bGVzOgogICAgICAgIGNsb3VkTWV0YWRhdGFTZXJ2ZXI6IHRydWUKICAgICAgICBkbnNQb3J0c1ByaXZhdGVJUHM6IHRydWUKICAgICAgICBub25Qcml2YXRlSVBzOiB0cnVlCiAgICAgICAgcHJpdmF0ZUlQczogdHJ1ZQogICAgICBlbmFibGVkOiB0cnVlCiAgICAgIGluZ3Jlc3M6IFtdCiAgICAgIGludGVyTmFtZXNwYWNlQWNjZXNzTGFiZWxzOiBpZ25vcmUKICAgIG5vZGVTZWxlY3Rvcjoge30KICAgIHBkYjoKICAgICAgZW5hYmxlZDogZmFsc2UKICAgICAgbWF4VW5hdmFpbGFibGU6IG51bGwKICAgICAgbWluQXZhaWxhYmxlOiAxCiAgICByZXNvdXJjZXM6IHt9CiAgICByZXZpc2lvbkhpc3RvcnlMaW1pdDogbnVsbAogICAgc2VydmljZUFjY291bnQ6CiAgICAgIGFubm90YXRpb25zOiB7fQogICAgICBjcmVhdGU6IHRydWUKICAgICAgbmFtZTogbnVsbAogICAgdG9sZXJhdGlvbnM6IFtdCnJiYWM6CiAgY3JlYXRlOiB0cnVlCnNjaGVkdWxpbmc6CiAgY29yZVBvZHM6CiAgICBub2RlQWZmaW5pdHk6CiAgICAgIG1hdGNoTm9kZVB1cnBvc2U6IHByZWZlcgogICAgdG9sZXJhdGlvbnM6CiAgICAtIGVmZmVjdDogTm9TY2hlZHVsZQogICAgICBrZXk6IGh1Yi5qdXB5dGVyLm9yZy9kZWRpY2F0ZWQKICAgICAgb3BlcmF0b3I6IEVxdWFsCiAgICAgIHZhbHVlOiBjb3JlCiAgICAtIGVmZmVjdDogTm9TY2hlZHVsZQogICAgICBrZXk6IGh1Yi5qdXB5dGVyLm9yZ19kZWRpY2F0ZWQKICAgICAgb3BlcmF0b3I6IEVxdWFsCiAgICAgIHZhbHVlOiBjb3JlCiAgcG9kUHJpb3JpdHk6CiAgICBkZWZhdWx0UHJpb3JpdHk6IDAKICAgIGVuYWJsZWQ6IGZhbHNlCiAgICBnbG9iYWxEZWZhdWx0OiBmYWxzZQogICAgaW1hZ2VQdWxsZXJQcmlvcml0eTogLTUKICAgIHVzZXJQbGFjZWhvbGRlclByaW9yaXR5OiAtMTAKICB1c2VyUGxhY2Vob2xkZXI6CiAgICBhbm5vdGF0aW9uczoge30KICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBlbmFibGVkOiB0cnVlCiAgICBpbWFnZToKICAgICAgbmFtZTogcmVnaXN0cnkuazhzLmlvL3BhdXNlCiAgICAgIHB1bGxQb2xpY3k6IG51bGwKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogIjMuOSIKICAgIGxhYmVsczoge30KICAgIHJlcGxpY2FzOiAwCiAgICByZXNvdXJjZXM6IHt9CiAgICByZXZpc2lvbkhpc3RvcnlMaW1pdDogbnVsbAogIHVzZXJQb2RzOgogICAgbm9kZUFmZmluaXR5OgogICAgICBtYXRjaE5vZGVQdXJwb3NlOiBwcmVmZXIKICAgIHRvbGVyYXRpb25zOgogICAgLSBlZmZlY3Q6IE5vU2NoZWR1bGUKICAgICAga2V5OiBodWIuanVweXRlci5vcmcvZGVkaWNhdGVkCiAgICAgIG9wZXJhdG9yOiBFcXVhbAogICAgICB2YWx1ZTogdXNlcgogICAgLSBlZmZlY3Q6IE5vU2NoZWR1bGUKICAgICAga2V5OiBodWIuanVweXRlci5vcmdfZGVkaWNhdGVkCiAgICAgIG9wZXJhdG9yOiBFcXVhbAogICAgICB2YWx1ZTogdXNlcgogIHVzZXJTY2hlZHVsZXI6CiAgICBhbm5vdGF0aW9uczoge30KICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBlbmFibGVkOiB0cnVlCiAgICBleHRyYVBvZFNwZWM6IHt9CiAgICBpbWFnZToKICAgICAgbmFtZTogcmVnaXN0cnkuazhzLmlvL2t1YmUtc2NoZWR1bGVyCiAgICAgIHB1bGxQb2xpY3k6IG51bGwKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogdjEuMjYuNQogICAgbGFiZWxzOiB7fQogICAgbG9nTGV2ZWw6IDQKICAgIG5vZGVTZWxlY3Rvcjoge30KICAgIHBkYjoKICAgICAgZW5hYmxlZDogdHJ1ZQogICAgICBtYXhVbmF2YWlsYWJsZTogMQogICAgICBtaW5BdmFpbGFibGU6IG51bGwKICAgIHBsdWdpbkNvbmZpZzoKICAgIC0gYXJnczoKICAgICAgICBzY29yaW5nU3RyYXRlZ3k6CiAgICAgICAgICByZXNvdXJjZXM6CiAgICAgICAgICAtIG5hbWU6IGNwdQogICAgICAgICAgICB3ZWlnaHQ6IDEKICAgICAgICAgIC0gbmFtZTogbWVtb3J5CiAgICAgICAgICAgIHdlaWdodDogMQogICAgICAgICAgdHlwZTogTW9zdEFsbG9jYXRlZAogICAgICBuYW1lOiBOb2RlUmVzb3VyY2VzRml0CiAgICBwbHVnaW5zOgogICAgICBzY29yZToKICAgICAgICBkaXNhYmxlZDoKICAgICAgICAtIG5hbWU6IE5vZGVSZXNvdXJjZXNCYWxhbmNlZEFsbG9jYXRpb24KICAgICAgICAtIG5hbWU6IE5vZGVBZmZpbml0eQogICAgICAgIC0gbmFtZTogSW50ZXJQb2RBZmZpbml0eQogICAgICAgIC0gbmFtZTogTm9kZVJlc291cmNlc0ZpdAogICAgICAgIC0gbmFtZTogSW1hZ2VMb2NhbGl0eQogICAgICAgIGVuYWJsZWQ6CiAgICAgICAgLSBuYW1lOiBOb2RlQWZmaW5pdHkKICAgICAgICAgIHdlaWdodDogMTQ2MzEKICAgICAgICAtIG5hbWU6IEludGVyUG9kQWZmaW5pdHkKICAgICAgICAgIHdlaWdodDogMTMzMQogICAgICAgIC0gbmFtZTogTm9kZVJlc291cmNlc0ZpdAogICAgICAgICAgd2VpZ2h0OiAxMjEKICAgICAgICAtIG5hbWU6IEltYWdlTG9jYWxpdHkKICAgICAgICAgIHdlaWdodDogMTEKICAgIHJlcGxpY2FzOiAxCiAgICByZXNvdXJjZXM6IHt9CiAgICByZXZpc2lvbkhpc3RvcnlMaW1pdDogbnVsbAogICAgc2VydmljZUFjY291bnQ6CiAgICAgIGFubm90YXRpb25zOiB7fQogICAgICBjcmVhdGU6IHRydWUKICAgICAgbmFtZTogbnVsbAogICAgdG9sZXJhdGlvbnM6IFtdCnNpbmdsZXVzZXI6CiAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogIGNsb3VkTWV0YWRhdGE6CiAgICBibG9ja1dpdGhJcHRhYmxlczogZmFsc2UKICAgIGlwOiAxNjkuMjU0LjE2OS4yNTQKICBjbWQ6IGp1cHl0ZXJodWItc2luZ2xldXNlcgogIGNwdToKICAgIGd1YXJhbnRlZTogbnVsbAogICAgbGltaXQ6IG51bGwKICBkZWZhdWx0VXJsOiBudWxsCiAgZXZlbnRzOiB0cnVlCiAgZXh0cmFBbm5vdGF0aW9uczoge30KICBleHRyYUNvbnRhaW5lcnM6IFtdCiAgZXh0cmFFbnY6CiAgICBKVVBZVEVSSFVCX1NJTkdMRVVTRVJfQVBQOiBqdXB5dGVyX3NlcnZlci5zZXJ2ZXJhcHAuU2VydmVyQXBwCiAgZXh0cmFGaWxlczoKICAgIG5vdGVib29rX2NvbmZpZzoKICAgICAgbW91bnRQYXRoOiAvdXNyL2xvY2FsL2V0Yy9qdXB5dGVyL2p1cHl0ZXJfc2VydmVyX2NvbmZpZy5weQogICAgICBzdHJpbmdEYXRhOiB8CiAgICAgICAgaW1wb3J0IG9zCiAgICAgICAgZnJvbSBoeWJyaWRjb250ZW50cyBpbXBvcnQgSHlicmlkQ29udGVudHNNYW5hZ2VyCiAgICAgICAgZnJvbSBzM2NvbnRlbnRzLmdjcyBpbXBvcnQgR0NTQ29udGVudHNNYW5hZ2VyCiAgICAgICAgZnJvbSBub3RlYm9vay5zZXJ2aWNlcy5jb250ZW50cy5sYXJnZWZpbGVtYW5hZ2VyIGltcG9ydCBMYXJnZUZpbGVNYW5hZ2VyCgogICAgICAgIG9zLmVudmlyb25bJ1RFU1RfVVNFUl9QUk9QQUdBVElPTiddID0gb3MuZW52aXJvbi5nZXQoJ1BST1BfVVNFUl9JTkZPJykKICAgICAgICBvcy5lbnZpcm9uWydURVNUX1BST0ZJTEVfUFJPUEFHQVRJT04nXSA9IG9zLmVudmlyb24uZ2V0KCdQUk9QX1VTRVJfUFJPRklMRScpCgogICAgICAgIGMuU2VydmVyQXBwLmNvbnRlbnRzX21hbmFnZXJfY2xhc3MgPSBIeWJyaWRDb250ZW50c01hbmFnZXIKICAgICAgICBjLkh5YnJpZENvbnRlbnRzTWFuYWdlci5tYW5hZ2VyX2NsYXNzZXMgPSB7CiAgICAgICAgICAgICIiOiBHQ1NDb250ZW50c01hbmFnZXIsCiAgICAgICAgICAgICJzY3JhdGNoIjogTGFyZ2VGaWxlTWFuYWdlcgogICAgICAgIH0KICAgICAgICBjLkh5YnJpZENvbnRlbnRzTWFuYWdlci5tYW5hZ2VyX2t3YXJncyA9IHsKICAgICAgICAgICIiOiB7InByb2plY3QiOiAibGFicy1nb3Zlcm5hbmNlIiwgImJ1Y2tldCI6ICJqdXB5dGVyaHViLTg2bGFicy1rOHMtc3RvcmFnZSJ9LAogICAgICAgICAgInNjcmF0Y2giOiB7InJvb3RfZGlyIjogIi9ob21lL2pvdnlhbiJ9CiAgICAgICAgfQogICAgICAgIGMuSHlicmlkQ29udGVudHNNYW5hZ2VyLm1hbmFnZXJzID0gewogICAgICAgICAgazogdigqKmMuSHlicmlkQ29udGVudHNNYW5hZ2VyLm1hbmFnZXJfa3dhcmdzLmdldChrKSkgZm9yIGssdiBpbiBjLkh5YnJpZENvbnRlbnRzTWFuYWdlci5tYW5hZ2VyX2NsYXNzZXMuaXRlbXMoKQogICAgICAgIH0KICBleHRyYUxhYmVsczoKICAgIGh1Yi5qdXB5dGVyLm9yZy9uZXR3b3JrLWFjY2Vzcy1odWI6ICJ0cnVlIgogIGV4dHJhTm9kZUFmZmluaXR5OgogICAgcHJlZmVycmVkOiBbXQogICAgcmVxdWlyZWQ6IFtdCiAgZXh0cmFQb2RBZmZpbml0eToKICAgIHByZWZlcnJlZDogW10KICAgIHJlcXVpcmVkOiBbXQogIGV4dHJhUG9kQW50aUFmZmluaXR5OgogICAgcHJlZmVycmVkOiBbXQogICAgcmVxdWlyZWQ6IFtdCiAgZXh0cmFQb2RDb25maWc6IHt9CiAgZXh0cmFSZXNvdXJjZToKICAgIGd1YXJhbnRlZXM6IHt9CiAgICBsaW1pdHM6IHt9CiAgZXh0cmFUb2xlcmF0aW9uczoKICAtIGVmZmVjdDogTm9TY2hlZHVsZQogICAga2V5OiBlcGhlbWVyYWwKICAgIG9wZXJhdG9yOiBFcXVhbAogICAgdmFsdWU6ICJ0cnVlIgogIGZzR2lkOiAxMDAKICBpbWFnZToKICAgIG5hbWU6IGp1cHl0ZXJodWIvazhzLXNpbmdsZXVzZXItc2FtcGxlCiAgICBwdWxsUG9saWN5OiBudWxsCiAgICBwdWxsU2VjcmV0czogW10KICAgIHRhZzogMy4wLjAtMC5kZXYuZ2l0LjYxNjcuaGE2OWQ4ZWM2CiAgaW5pdENvbnRhaW5lcnM6IFtdCiAgbGlmZWN5Y2xlSG9va3M6IHt9CiAgbWVtb3J5OgogICAgZ3VhcmFudGVlOiAxRwogICAgbGltaXQ6IG51bGwKICBuZXR3b3JrUG9saWN5OgogICAgYWxsb3dlZEluZ3Jlc3NQb3J0czogW10KICAgIGVncmVzczogW10KICAgIGVncmVzc0FsbG93UnVsZXM6CiAgICAgIGNsb3VkTWV0YWRhdGFTZXJ2ZXI6IGZhbHNlCiAgICAgIGRuc1BvcnRzUHJpdmF0ZUlQczogdHJ1ZQogICAgICBub25Qcml2YXRlSVBzOiB0cnVlCiAgICAgIHByaXZhdGVJUHM6IGZhbHNlCiAgICBlbmFibGVkOiB0cnVlCiAgICBpbmdyZXNzOiBbXQogICAgaW50ZXJOYW1lc3BhY2VBY2Nlc3NMYWJlbHM6IGlnbm9yZQogIG5ldHdvcmtUb29sczoKICAgIGltYWdlOgogICAgICBuYW1lOiBqdXB5dGVyaHViL2s4cy1uZXR3b3JrLXRvb2xzCiAgICAgIHB1bGxQb2xpY3k6IG51bGwKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogMy4wLjAtMC5kZXYuZ2l0LjYxNTkuaDUwYTA4ZmFkCiAgICByZXNvdXJjZXM6IHt9CiAgbm9kZVNlbGVjdG9yOgogICAgY2xvdWQuZ29vZ2xlLmNvbS9na2Utbm9kZXBvb2w6IGVwaGVtZXJhbC1wb29sCiAgcG9kTmFtZVRlbXBsYXRlOiBudWxsCiAgcHJvZmlsZUxpc3Q6IFtdCiAgc2VydmljZUFjY291bnROYW1lOiBudWxsCiAgc3RhcnRUaW1lb3V0OiAzMDAKICBzdG9yYWdlOgogICAgY2FwYWNpdHk6IDEwR2kKICAgIGR5bmFtaWM6CiAgICAgIHB2Y05hbWVUZW1wbGF0ZTogY2xhaW0te3VzZXJuYW1lfXtzZXJ2ZXJuYW1lfQogICAgICBzdG9yYWdlQWNjZXNzTW9kZXM6CiAgICAgIC0gUmVhZFdyaXRlT25jZQogICAgICBzdG9yYWdlQ2xhc3M6IG51bGwKICAgICAgdm9sdW1lTmFtZVRlbXBsYXRlOiB2b2x1bWUte3VzZXJuYW1lfXtzZXJ2ZXJuYW1lfQogICAgZXh0cmFMYWJlbHM6IHt9CiAgICBleHRyYVZvbHVtZU1vdW50czogW10KICAgIGV4dHJhVm9sdW1lczogW10KICAgIGhvbWVNb3VudFBhdGg6IC9ob21lL2pvdnlhbgogICAgc3RhdGljOgogICAgICBwdmNOYW1lOiBudWxsCiAgICAgIHN1YlBhdGg6ICd7dXNlcm5hbWV9JwogICAgdHlwZTogZHluYW1pYwogIHVpZDogMTAwMA=="

  # Any JupyterHub Services api_tokens are exposed in this k8s Secret as a
  # convinience for external services running in the k8s cluster that could
  # mount them directly from this k8s Secret.

  # During Helm template rendering, these values that can be autogenerated for
  # users are set using the following logic:
  #
  # 1. Use chart configuration's value
  # 2. Use k8s Secret's value
  # 3. Use a new autogenerated value
  #
  # hub.config.ConfigurableHTTPProxy.auth_token: for hub to proxy-api authorization (JupyterHub.proxy_auth_token is deprecated)
  # hub.config.JupyterHub.cookie_secret:         for cookie encryption
  # hub.config.CryptKeeper.keys:                 for auth state encryption
  #
  hub.config.ConfigurableHTTPProxy.auth_token: "azM5YkFJMzd5dFg5UE13bjU0cjZOZVlRYjF5c0tFSFA5YW1SQldVRlNrbUJ3dFNCZFQ3bWUwSjcwTG5VM0hidQ=="
  hub.config.JupyterHub.cookie_secret: "YWZmNzViMTM2NjQwOWQ0ZWFjZTAxOTZlMzUzOGMyOWVkNjQ4OTkyZGM2MmJmYzIwNGFkNTYxN2JhYjhiNzQ2Mw=="
  hub.config.CryptKeeper.keys: "MDFiMmVjMjJiYWEzM2FlOWVlMzk2MGJkY2E5N2NlMWRkNTc0NmYyNTMwYjU2YzZlNTFkZjliNDhlZDJmMzNhZA=="
stringData:
  "bind_url_config": |
    c.JupyterHub.bind_url = 'https://jupyterhub.prod.k8s.86labs.com'
    c.JupyterHub.admin_access = True
  "custom_kube_spawner": |
    import json
    from kubespawner import KubeSpawner
    from kubernetes_asyncio.client import models as k8s
    
    class CustomKubeSpawner(KubeSpawner):
        def auth_state_hook(self, spawner, auth_state):
            """
            This user hook attaches the user information to the spawner,
            which we can use when generating the profile list.
            This allows us to have kubernetes overrides base on OAuth2 attributes.
            """
            userinfo = auth_state.get("oauth_user")
            self.log.info(f"got user info {userinfo}")
            spawner.userinfo = userinfo
    
        def profile_list(self, spawner):
            """
            The profile list for the KubeSpawner can be a callable from the Spawner object
            Allowing us to dynamically generate profiles based on the user info
            """
            user_info = spawner.userinfo
            image_options = {"display_name": "Image", "choices": {"custom": {"display_name": "Custom Single Server", "kubespawner_override": {"image": "gfeldman8/jupyterhub-k8s-singleuser:latest"} } , "pytorch2": {"display_name": "Python 3 Training Notebook 2", "kubespawner_override": {"image": "training/python:2022.01.01"} } }}
            return [{'display_name': f'Training Env for {user_info.get("name")}', 'slug': 'training-python', 'default': True, "profile_options": {"image": image_options} }, {'display_name': f'Prod Env for {user_info.get("name")}','slug': 'prod-python','default': False}]
    
        def get_env(self):
            env = super().get_env()
            if hasattr(self,'userinfo'):
                env['PROP_USER_INFO'] = self.userinfo.get("name", "")
            if hasattr(self, 'user_options'):
                env['PROP_USER_PROFILE'] = self.user_options.get("profile","")
            self.log.info(f"Got environment variables {env}")
            return env
        
        def get_service_account_from_user_info(self, spawner):
            user_info = spawner.userinfo
            self.log.info(f"got user info in modify_pod_hook {user_info}")
            return "jupyterhub-user"
        
        def modify_pod_hook(self, spawner, pod: k8s.V1Pod):
            # set service account based on user info
            pod.spec.service_account = self.get_service_account_from_user_info(spawner)
            pod.spec.service_account_name = self.get_service_account_from_user_info(spawner)
            pod.spec.automount_service_account_token = True
            # set user root to read only file system so they do not store files there permanently
            pod.spec.volumes.append(k8s.V1Volume(name="jupyter-root",empty_dir=k8s.V1EmptyDirVolumeSource()))
            pod.spec.containers[0].volume_mounts.append(k8s.V1VolumeMount(name="jupyter-root", mount_path="/tmp/container",read_only=False))
            pod.spec.containers[0].image_pull_policy = "Always"
            self.log.info(f"got pod in modify_pod_hook {pod}")
            return pod
  "keycloak_authenticator": |
    from oauthenticator.generic import GenericOAuthenticator
    # subclassing the GenericOAuthenticator in case we need to 
    # enrich the user info
    # https://github.com/jupyterhub/oauthenticator/blob/main/oauthenticator/generic.py
    
    class KeycloakAuthenticator(GenericOAuthenticator):
        login_service = 'keycloak'
        userdata_params = {"state": "state"}
        username_key =  "preferred_username"
        admin_groups = ["jupyterhub-admin"]
        allowed_groups = ["jupyterhub-user", "jupyterhub-admin"]
        enable_auth_state =  True
    
        def claim_groups_key(self, userinfo_data):
            return userinfo_data['jupyterhub_groups']
    
        
  "keycloak_config": |
    from keycloak_authenticator import KeycloakAuthenticator
    c.JupyterHub.authenticator_class = KeycloakAuthenticator
  "spawner_config": |
    from custom_kube_spawner import CustomKubeSpawner
    c.JupyterHub.spawner_class = CustomKubeSpawner
---
# Source: jupyterhub/templates/singleuser/secret.yaml
kind: Secret
apiVersion: v1
metadata:
  name: singleuser
  labels:
    component: singleuser
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
type: Opaque
stringData:
  "notebook_config": |
    import os
    from hybridcontents import HybridContentsManager
    from s3contents.gcs import GCSContentsManager
    from notebook.services.contents.largefilemanager import LargeFileManager
    
    os.environ['TEST_USER_PROPAGATION'] = os.environ.get('PROP_USER_INFO')
    os.environ['TEST_PROFILE_PROPAGATION'] = os.environ.get('PROP_USER_PROFILE')
    
    c.ServerApp.contents_manager_class = HybridContentsManager
    c.HybridContentsManager.manager_classes = {
        "": GCSContentsManager,
        "scratch": LargeFileManager
    }
    c.HybridContentsManager.manager_kwargs = {
      "": {"project": "labs-governance", "bucket": "jupyterhub-86labs-k8s-storage"},
      "scratch": {"root_dir": "/home/jovyan"}
    }
    c.HybridContentsManager.managers = {
      k: v(**c.HybridContentsManager.manager_kwargs.get(k)) for k,v in c.HybridContentsManager.manager_classes.items()
    }
---
# Source: jupyterhub/templates/hub/configmap.yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
data:
  fullname: ""
  fullname-dash: ""
  hub: "hub"
  hub-serviceaccount: "hub"
  hub-existing-secret: ""
  hub-existing-secret-or-default: "hub"
  hub-pvc: "hub-db-dir"
  proxy: "proxy"
  proxy-api: "proxy-api"
  proxy-http: "proxy-http"
  proxy-public: "proxy-public"
  proxy-public-tls: "proxy-public-tls-acme"
  proxy-public-manual-tls: "proxy-public-manual-tls"
  autohttps: "autohttps"
  autohttps-serviceaccount: "autohttps"
  user-scheduler-deploy: "user-scheduler"
  user-scheduler-serviceaccount: "user-scheduler"
  user-scheduler-lock: "user-scheduler-lock"
  user-placeholder: "user-placeholder"
  image-puller-priority: "jupyterhub-image-puller-priority"
  hook-image-awaiter: "hook-image-awaiter"
  hook-image-awaiter-serviceaccount: "hook-image-awaiter"
  hook-image-puller: "hook-image-puller"
  continuous-image-puller: "continuous-image-puller"
  singleuser: "singleuser"
  image-pull-secret: "image-pull-secret"
  ingress: "jupyterhub"
  priority: "jupyterhub-default-priority"
  user-placeholder-priority: "jupyterhub-user-placeholder-priority"
  user-scheduler: "jupyterhub-user-scheduler"
  jupyterhub_config.py: |
    # load the config object (satisfies linters)
    c = get_config()  # noqa
  
    import glob
    import os
    import re
    import sys
  
    from jupyterhub.utils import url_path_join
    from kubernetes_asyncio import client
    from tornado.httpclient import AsyncHTTPClient
  
    # Make sure that modules placed in the same directory as the jupyterhub config are added to the pythonpath
    configuration_directory = os.path.dirname(os.path.realpath(__file__))
    sys.path.insert(0, configuration_directory)
  
    from z2jh import (
        get_config,
        get_name,
        get_name_env,
        get_secret_value,
        set_config_if_not_none,
    )
  
  
    def camelCaseify(s):
        """convert snake_case to camelCase
  
        For the common case where some_value is set from someValue
        so we don't have to specify the name twice.
        """
        return re.sub(r"_([a-z])", lambda m: m.group(1).upper(), s)
  
  
    # Configure JupyterHub to use the curl backend for making HTTP requests,
    # rather than the pure-python implementations. The default one starts
    # being too slow to make a large number of requests to the proxy API
    # at the rate required.
    AsyncHTTPClient.configure("tornado.curl_httpclient.CurlAsyncHTTPClient")
  
    c.JupyterHub.spawner_class = "kubespawner.KubeSpawner"
  
    # Connect to a proxy running in a different pod. Note that *_SERVICE_*
    # environment variables are set by Kubernetes for Services
    c.ConfigurableHTTPProxy.api_url = (
        f'http://{get_name("proxy-api")}:{get_name_env("proxy-api", "_SERVICE_PORT")}'
    )
    c.ConfigurableHTTPProxy.should_start = False
  
    # Do not shut down user pods when hub is restarted
    c.JupyterHub.cleanup_servers = False
  
    # Check that the proxy has routes appropriately setup
    c.JupyterHub.last_activity_interval = 60
  
    # Don't wait at all before redirecting a spawning user to the progress page
    c.JupyterHub.tornado_settings = {
        "slow_spawn_timeout": 0,
    }
  
  
    # configure the hub db connection
    db_type = get_config("hub.db.type")
    if db_type == "sqlite-pvc":
        c.JupyterHub.db_url = "sqlite:///jupyterhub.sqlite"
    elif db_type == "sqlite-memory":
        c.JupyterHub.db_url = "sqlite://"
    else:
        set_config_if_not_none(c.JupyterHub, "db_url", "hub.db.url")
    db_password = get_secret_value("hub.db.password", None)
    if db_password is not None:
        if db_type == "mysql":
            os.environ["MYSQL_PWD"] = db_password
        elif db_type == "postgres":
            os.environ["PGPASSWORD"] = db_password
        else:
            print(f"Warning: hub.db.password is ignored for hub.db.type={db_type}")
  
  
    # c.JupyterHub configuration from Helm chart's configmap
    for trait, cfg_key in (
        ("concurrent_spawn_limit", None),
        ("active_server_limit", None),
        ("base_url", None),
        ("allow_named_servers", None),
        ("named_server_limit_per_user", None),
        ("authenticate_prometheus", None),
        ("redirect_to_server", None),
        ("shutdown_on_logout", None),
        ("template_paths", None),
        ("template_vars", None),
    ):
        if cfg_key is None:
            cfg_key = camelCaseify(trait)
        set_config_if_not_none(c.JupyterHub, trait, "hub." + cfg_key)
  
    # hub_bind_url configures what the JupyterHub process within the hub pod's
    # container should listen to.
    hub_container_port = 8081
    c.JupyterHub.hub_bind_url = f"http://:{hub_container_port}"
  
    # hub_connect_url is the URL for connecting to the hub for use by external
    # JupyterHub services such as the proxy. Note that *_SERVICE_* environment
    # variables are set by Kubernetes for Services.
    c.JupyterHub.hub_connect_url = (
        f'http://{get_name("hub")}:{get_name_env("hub", "_SERVICE_PORT")}'
    )
  
    # implement common labels
    # this duplicates the jupyterhub.commonLabels helper
    common_labels = c.KubeSpawner.common_labels = {}
    common_labels["app"] = get_config(
        "nameOverride",
        default=get_config("Chart.Name", "jupyterhub"),
    )
    common_labels["heritage"] = "jupyterhub"
    chart_name = get_config("Chart.Name")
    chart_version = get_config("Chart.Version")
    if chart_name and chart_version:
        common_labels["chart"] = "{}-{}".format(
            chart_name,
            chart_version.replace("+", "_"),
        )
    release = get_config("Release.Name")
    if release:
        common_labels["release"] = release
  
    c.KubeSpawner.namespace = os.environ.get("POD_NAMESPACE", "default")
  
    # Max number of consecutive failures before the Hub restarts itself
    # requires jupyterhub 0.9.2
    set_config_if_not_none(
        c.Spawner,
        "consecutive_failure_limit",
        "hub.consecutiveFailureLimit",
    )
  
    for trait, cfg_key in (
        ("pod_name_template", None),
        ("start_timeout", None),
        ("image_pull_policy", "image.pullPolicy"),
        # ('image_pull_secrets', 'image.pullSecrets'), # Managed manually below
        ("events_enabled", "events"),
        ("extra_labels", None),
        ("extra_annotations", None),
        # ("allow_privilege_escalation", None), # Managed manually below
        ("uid", None),
        ("fs_gid", None),
        ("service_account", "serviceAccountName"),
        ("storage_extra_labels", "storage.extraLabels"),
        # ("tolerations", "extraTolerations"), # Managed manually below
        ("node_selector", None),
        ("node_affinity_required", "extraNodeAffinity.required"),
        ("node_affinity_preferred", "extraNodeAffinity.preferred"),
        ("pod_affinity_required", "extraPodAffinity.required"),
        ("pod_affinity_preferred", "extraPodAffinity.preferred"),
        ("pod_anti_affinity_required", "extraPodAntiAffinity.required"),
        ("pod_anti_affinity_preferred", "extraPodAntiAffinity.preferred"),
        ("lifecycle_hooks", None),
        ("init_containers", None),
        ("extra_containers", None),
        ("mem_limit", "memory.limit"),
        ("mem_guarantee", "memory.guarantee"),
        ("cpu_limit", "cpu.limit"),
        ("cpu_guarantee", "cpu.guarantee"),
        ("extra_resource_limits", "extraResource.limits"),
        ("extra_resource_guarantees", "extraResource.guarantees"),
        ("environment", "extraEnv"),
        ("profile_list", None),
        ("extra_pod_config", None),
    ):
        if cfg_key is None:
            cfg_key = camelCaseify(trait)
        set_config_if_not_none(c.KubeSpawner, trait, "singleuser." + cfg_key)
  
    image = get_config("singleuser.image.name")
    if image:
        tag = get_config("singleuser.image.tag")
        if tag:
            image = f"{image}:{tag}"
  
        c.KubeSpawner.image = image
  
    # allow_privilege_escalation defaults to False in KubeSpawner 2+. Since its a
    # property where None, False, and True all are valid values that users of the
    # Helm chart may want to set, we can't use the set_config_if_not_none helper
    # function as someone may want to override the default False value to None.
    #
    c.KubeSpawner.allow_privilege_escalation = get_config(
        "singleuser.allowPrivilegeEscalation"
    )
  
    # Combine imagePullSecret.create (single), imagePullSecrets (list), and
    # singleuser.image.pullSecrets (list).
    image_pull_secrets = []
    if get_config("imagePullSecret.automaticReferenceInjection") and get_config(
        "imagePullSecret.create"
    ):
        image_pull_secrets.append(get_name("image-pull-secret"))
    if get_config("imagePullSecrets"):
        image_pull_secrets.extend(get_config("imagePullSecrets"))
    if get_config("singleuser.image.pullSecrets"):
        image_pull_secrets.extend(get_config("singleuser.image.pullSecrets"))
    if image_pull_secrets:
        c.KubeSpawner.image_pull_secrets = image_pull_secrets
  
    # scheduling:
    if get_config("scheduling.userScheduler.enabled"):
        c.KubeSpawner.scheduler_name = get_name("user-scheduler")
    if get_config("scheduling.podPriority.enabled"):
        c.KubeSpawner.priority_class_name = get_name("priority")
  
    # add node-purpose affinity
    match_node_purpose = get_config("scheduling.userPods.nodeAffinity.matchNodePurpose")
    if match_node_purpose:
        node_selector = dict(
            matchExpressions=[
                dict(
                    key="hub.jupyter.org/node-purpose",
                    operator="In",
                    values=["user"],
                )
            ],
        )
        if match_node_purpose == "prefer":
            c.KubeSpawner.node_affinity_preferred.append(
                dict(
                    weight=100,
                    preference=node_selector,
                ),
            )
        elif match_node_purpose == "require":
            c.KubeSpawner.node_affinity_required.append(node_selector)
        elif match_node_purpose == "ignore":
            pass
        else:
            raise ValueError(
                f"Unrecognized value for matchNodePurpose: {match_node_purpose}"
            )
  
    # Combine the common tolerations for user pods with singleuser tolerations
    scheduling_user_pods_tolerations = get_config("scheduling.userPods.tolerations", [])
    singleuser_extra_tolerations = get_config("singleuser.extraTolerations", [])
    tolerations = scheduling_user_pods_tolerations + singleuser_extra_tolerations
    if tolerations:
        c.KubeSpawner.tolerations = tolerations
  
    # Configure dynamically provisioning pvc
    storage_type = get_config("singleuser.storage.type")
    if storage_type == "dynamic":
        pvc_name_template = get_config("singleuser.storage.dynamic.pvcNameTemplate")
        c.KubeSpawner.pvc_name_template = pvc_name_template
        volume_name_template = get_config("singleuser.storage.dynamic.volumeNameTemplate")
        c.KubeSpawner.storage_pvc_ensure = True
        set_config_if_not_none(
            c.KubeSpawner, "storage_class", "singleuser.storage.dynamic.storageClass"
        )
        set_config_if_not_none(
            c.KubeSpawner,
            "storage_access_modes",
            "singleuser.storage.dynamic.storageAccessModes",
        )
        set_config_if_not_none(
            c.KubeSpawner, "storage_capacity", "singleuser.storage.capacity"
        )
  
        # Add volumes to singleuser pods
        c.KubeSpawner.volumes = [
            {
                "name": volume_name_template,
                "persistentVolumeClaim": {"claimName": pvc_name_template},
            }
        ]
        c.KubeSpawner.volume_mounts = [
            {
                "mountPath": get_config("singleuser.storage.homeMountPath"),
                "name": volume_name_template,
            }
        ]
    elif storage_type == "static":
        pvc_claim_name = get_config("singleuser.storage.static.pvcName")
        c.KubeSpawner.volumes = [
            {"name": "home", "persistentVolumeClaim": {"claimName": pvc_claim_name}}
        ]
  
        c.KubeSpawner.volume_mounts = [
            {
                "mountPath": get_config("singleuser.storage.homeMountPath"),
                "name": "home",
                "subPath": get_config("singleuser.storage.static.subPath"),
            }
        ]
  
    # Inject singleuser.extraFiles as volumes and volumeMounts with data loaded from
    # the dedicated k8s Secret prepared to hold the extraFiles actual content.
    extra_files = get_config("singleuser.extraFiles", {})
    if extra_files:
        volume = {
            "name": "files",
        }
        items = []
        for file_key, file_details in extra_files.items():
            # Each item is a mapping of a key in the k8s Secret to a path in this
            # abstract volume, the goal is to enable us to set the mode /
            # permissions only though so we don't change the mapping.
            item = {
                "key": file_key,
                "path": file_key,
            }
            if "mode" in file_details:
                item["mode"] = file_details["mode"]
            items.append(item)
        volume["secret"] = {
            "secretName": get_name("singleuser"),
            "items": items,
        }
        c.KubeSpawner.volumes.append(volume)
  
        volume_mounts = []
        for file_key, file_details in extra_files.items():
            volume_mounts.append(
                {
                    "mountPath": file_details["mountPath"],
                    "subPath": file_key,
                    "name": "files",
                }
            )
        c.KubeSpawner.volume_mounts.extend(volume_mounts)
  
    # Inject extraVolumes / extraVolumeMounts
    c.KubeSpawner.volumes.extend(get_config("singleuser.storage.extraVolumes", []))
    c.KubeSpawner.volume_mounts.extend(
        get_config("singleuser.storage.extraVolumeMounts", [])
    )
  
    c.JupyterHub.services = []
    c.JupyterHub.load_roles = []
  
    # jupyterhub-idle-culler's permissions are scoped to what it needs only, see
    # https://github.com/jupyterhub/jupyterhub-idle-culler#permissions.
    #
    if get_config("cull.enabled", False):
        jupyterhub_idle_culler_role = {
            "name": "jupyterhub-idle-culler",
            "scopes": [
                "list:users",
                "read:users:activity",
                "read:servers",
                "delete:servers",
                # "admin:users", # dynamically added if --cull-users is passed
            ],
            # assign the role to a jupyterhub service, so it gains these permissions
            "services": ["jupyterhub-idle-culler"],
        }
  
        cull_cmd = ["python3", "-m", "jupyterhub_idle_culler"]
        base_url = c.JupyterHub.get("base_url", "/")
        cull_cmd.append("--url=http://localhost:8081" + url_path_join(base_url, "hub/api"))
  
        cull_timeout = get_config("cull.timeout")
        if cull_timeout:
            cull_cmd.append(f"--timeout={cull_timeout}")
  
        cull_every = get_config("cull.every")
        if cull_every:
            cull_cmd.append(f"--cull-every={cull_every}")
  
        cull_concurrency = get_config("cull.concurrency")
        if cull_concurrency:
            cull_cmd.append(f"--concurrency={cull_concurrency}")
  
        if get_config("cull.users"):
            cull_cmd.append("--cull-users")
            jupyterhub_idle_culler_role["scopes"].append("admin:users")
  
        if not get_config("cull.adminUsers"):
            cull_cmd.append("--cull-admin-users=false")
  
        if get_config("cull.removeNamedServers"):
            cull_cmd.append("--remove-named-servers")
  
        cull_max_age = get_config("cull.maxAge")
        if cull_max_age:
            cull_cmd.append(f"--max-age={cull_max_age}")
  
        c.JupyterHub.services.append(
            {
                "name": "jupyterhub-idle-culler",
                "command": cull_cmd,
            }
        )
        c.JupyterHub.load_roles.append(jupyterhub_idle_culler_role)
  
    for key, service in get_config("hub.services", {}).items():
        # c.JupyterHub.services is a list of dicts, but
        # hub.services is a dict of dicts to make the config mergable
        service.setdefault("name", key)
  
        # As the api_token could be exposed in hub.existingSecret, we need to read
        # it it from there or fall back to the chart managed k8s Secret's value.
        service.pop("apiToken", None)
        service["api_token"] = get_secret_value(f"hub.services.{key}.apiToken")
  
        c.JupyterHub.services.append(service)
  
    for key, role in get_config("hub.loadRoles", {}).items():
        # c.JupyterHub.load_roles is a list of dicts, but
        # hub.loadRoles is a dict of dicts to make the config mergable
        role.setdefault("name", key)
  
        c.JupyterHub.load_roles.append(role)
  
    # respect explicit null command (distinct from unspecified)
    # this avoids relying on KubeSpawner.cmd's default being None
    _unspecified = object()
    specified_cmd = get_config("singleuser.cmd", _unspecified)
    if specified_cmd is not _unspecified:
        c.Spawner.cmd = specified_cmd
  
    set_config_if_not_none(c.Spawner, "default_url", "singleuser.defaultUrl")
  
    cloud_metadata = get_config("singleuser.cloudMetadata", {})
  
    if cloud_metadata.get("blockWithIptables") == True:
        # Use iptables to block access to cloud metadata by default
        network_tools_image_name = get_config("singleuser.networkTools.image.name")
        network_tools_image_tag = get_config("singleuser.networkTools.image.tag")
        network_tools_resources = get_config("singleuser.networkTools.resources")
        ip_block_container = client.V1Container(
            name="block-cloud-metadata",
            image=f"{network_tools_image_name}:{network_tools_image_tag}",
            command=[
                "iptables",
                "-A",
                "OUTPUT",
                "-d",
                cloud_metadata.get("ip", "169.254.169.254"),
                "-j",
                "DROP",
            ],
            security_context=client.V1SecurityContext(
                privileged=True,
                run_as_user=0,
                capabilities=client.V1Capabilities(add=["NET_ADMIN"]),
            ),
            resources=network_tools_resources,
        )
  
        c.KubeSpawner.init_containers.append(ip_block_container)
  
  
    if get_config("debug.enabled", False):
        c.JupyterHub.log_level = "DEBUG"
        c.Spawner.debug = True
  
    # load potentially seeded secrets
    #
    # NOTE: ConfigurableHTTPProxy.auth_token is set through an environment variable
    #       that is set using the chart managed secret.
    c.JupyterHub.cookie_secret = get_secret_value("hub.config.JupyterHub.cookie_secret")
    # NOTE: CryptKeeper.keys should be a list of strings, but we have encoded as a
    #       single string joined with ; in the k8s Secret.
    #
    c.CryptKeeper.keys = get_secret_value("hub.config.CryptKeeper.keys").split(";")
  
    # load hub.config values, except potentially seeded secrets already loaded
    for app, cfg in get_config("hub.config", {}).items():
        if app == "JupyterHub":
            cfg.pop("proxy_auth_token", None)
            cfg.pop("cookie_secret", None)
            cfg.pop("services", None)
        elif app == "ConfigurableHTTPProxy":
            cfg.pop("auth_token", None)
        elif app == "CryptKeeper":
            cfg.pop("keys", None)
        c[app].update(cfg)
  
    # load /usr/local/etc/jupyterhub/jupyterhub_config.d config files
    config_dir = "/usr/local/etc/jupyterhub/jupyterhub_config.d"
    if os.path.isdir(config_dir):
        for file_path in sorted(glob.glob(f"{config_dir}/*.py")):
            file_name = os.path.basename(file_path)
            print(f"Loading {config_dir} config: {file_name}")
            with open(file_path) as f:
                file_content = f.read()
            # compiling makes debugging easier: https://stackoverflow.com/a/437857
            exec(compile(source=file_content, filename=file_name, mode="exec"))
  
    # execute hub.extraConfig entries
    for key, config_py in sorted(get_config("hub.extraConfig", {}).items()):
        print(f"Loading extra config: {key}")
        exec(config_py)
  z2jh.py: |
    """
    Utility methods for use in jupyterhub_config.py and dynamic subconfigs.
  
    Methods here can be imported by extraConfig in values.yaml
    """
    import os
    from collections.abc import Mapping
    from functools import lru_cache
  
    import yaml
  
  
    # memoize so we only load config once
    @lru_cache
    def _load_config():
        """Load the Helm chart configuration used to render the Helm templates of
        the chart from a mounted k8s Secret, and merge in values from an optionally
        mounted secret (hub.existingSecret)."""
  
        cfg = {}
        for source in ("secret/values.yaml", "existing-secret/values.yaml"):
            path = f"/usr/local/etc/jupyterhub/{source}"
            if os.path.exists(path):
                print(f"Loading {path}")
                with open(path) as f:
                    values = yaml.safe_load(f)
                cfg = _merge_dictionaries(cfg, values)
            else:
                print(f"No config at {path}")
        return cfg
  
  
    @lru_cache
    def _get_config_value(key):
        """Load value from the k8s ConfigMap given a key."""
  
        path = f"/usr/local/etc/jupyterhub/config/{key}"
        if os.path.exists(path):
            with open(path) as f:
                return f.read()
        else:
            raise Exception(f"{path} not found!")
  
  
    @lru_cache
    def get_secret_value(key, default="never-explicitly-set"):
        """Load value from the user managed k8s Secret or the default k8s Secret
        given a key."""
  
        for source in ("existing-secret", "secret"):
            path = f"/usr/local/etc/jupyterhub/{source}/{key}"
            if os.path.exists(path):
                with open(path) as f:
                    return f.read()
        if default != "never-explicitly-set":
            return default
        raise Exception(f"{key} not found in either k8s Secret!")
  
  
    def get_name(name):
        """Returns the fullname of a resource given its short name"""
        return _get_config_value(name)
  
  
    def get_name_env(name, suffix=""):
        """Returns the fullname of a resource given its short name along with a
        suffix, converted to uppercase with dashes replaced with underscores. This
        is useful to reference named services associated environment variables, such
        as PROXY_PUBLIC_SERVICE_PORT."""
        env_key = _get_config_value(name) + suffix
        env_key = env_key.upper().replace("-", "_")
        return os.environ[env_key]
  
  
    def _merge_dictionaries(a, b):
        """Merge two dictionaries recursively.
  
        Simplified From https://stackoverflow.com/a/7205107
        """
        merged = a.copy()
        for key in b:
            if key in a:
                if isinstance(a[key], Mapping) and isinstance(b[key], Mapping):
                    merged[key] = _merge_dictionaries(a[key], b[key])
                else:
                    merged[key] = b[key]
            else:
                merged[key] = b[key]
        return merged
  
  
    def get_config(key, default=None):
        """
        Find a config item of a given name & return it
  
        Parses everything as YAML, so lists and dicts are available too
  
        get_config("a.b.c") returns config['a']['b']['c']
        """
        value = _load_config()
        # resolve path in yaml
        for level in key.split("."):
            if not isinstance(value, dict):
                # a parent is a scalar or null,
                # can't resolve full path
                return default
            if level not in value:
                return default
            else:
                value = value[level]
        return value
  
  
    def set_config_if_not_none(cparent, name, key):
        """
        Find a config item of a given name, set the corresponding Jupyter
        configuration item if not None
        """
        data = get_config(key)
        if data is not None:
            setattr(cparent, name, data)
  checksum_hook-image-puller: "e7e60844234e9c740573c1e6e8e13cca1968a61aafad4b86090ddb430207e943"
---
# Source: jupyterhub/templates/scheduling/user-scheduler/configmap.yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
data:
  config.yaml: |
    apiVersion: kubescheduler.config.k8s.io/v1
    kind: KubeSchedulerConfiguration
    leaderElection:
      resourceLock: endpointsleases
      resourceName: user-scheduler-lock
      resourceNamespace: "jupyterhub"
    profiles:
      - schedulerName: jupyterhub-user-scheduler
        plugins:
          score:
            disabled:
            - name: NodeResourcesBalancedAllocation
            - name: NodeAffinity
            - name: InterPodAffinity
            - name: NodeResourcesFit
            - name: ImageLocality
            enabled:
            - name: NodeAffinity
              weight: 14631
            - name: InterPodAffinity
              weight: 1331
            - name: NodeResourcesFit
              weight: 121
            - name: ImageLocality
              weight: 11
        pluginConfig:
          - args:
              scoringStrategy:
                resources:
                - name: cpu
                  weight: 1
                - name: memory
                  weight: 1
                type: MostAllocated
            name: NodeResourcesFit
---
# Source: jupyterhub/templates/hub/pvc.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: hub-db-dir
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: "1Gi"
---
# Source: jupyterhub/templates/scheduling/user-scheduler/rbac.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jupyterhub-user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
rules:
  # Copied from the system:kube-scheduler ClusterRole of the k8s version
  # matching the kube-scheduler binary we use. A modification has been made to
  # resourceName fields to remain relevant for how we have named our resources
  # in this Helm chart.
  #
  # NOTE: These rules have been:
  #       - unchanged between 1.12 and 1.15
  #       - changed in 1.16
  #       - changed in 1.17
  #       - unchanged between 1.18 and 1.20
  #       - changed in 1.21: get/list/watch permission for namespace,
  #                          csidrivers, csistoragecapacities was added.
  #       - unchanged between 1.22 and 1.27
  #
  # ref: https://github.com/kubernetes/kubernetes/blob/v1.27.0/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/testdata/cluster-roles.yaml#L736-L892
  - apiGroups:
    - ""
    - events.k8s.io
    resources:
    - events
    verbs:
    - create
    - patch
    - update
  - apiGroups:
    - coordination.k8s.io
    resources:
    - leases
    verbs:
    - create
  - apiGroups:
    - coordination.k8s.io
    resourceNames:
    - user-scheduler-lock
    resources:
    - leases
    verbs:
    - get
    - update
  - apiGroups:
    - ""
    resources:
    - endpoints
    verbs:
    - create
  - apiGroups:
    - ""
    resourceNames:
    - user-scheduler-lock
    resources:
    - endpoints
    verbs:
    - get
    - update
  - apiGroups:
    - ""
    resources:
    - nodes
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - pods
    verbs:
    - delete
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - bindings
    - pods/binding
    verbs:
    - create
  - apiGroups:
    - ""
    resources:
    - pods/status
    verbs:
    - patch
    - update
  - apiGroups:
    - ""
    resources:
    - replicationcontrollers
    - services
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - apps
    - extensions
    resources:
    - replicasets
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - apps
    resources:
    - statefulsets
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - policy
    resources:
    - poddisruptionbudgets
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - persistentvolumeclaims
    - persistentvolumes
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - authentication.k8s.io
    resources:
    - tokenreviews
    verbs:
    - create
  - apiGroups:
    - authorization.k8s.io
    resources:
    - subjectaccessreviews
    verbs:
    - create
  - apiGroups:
    - storage.k8s.io
    resources:
    - csinodes
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - namespaces
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - storage.k8s.io
    resources:
    - csidrivers
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - storage.k8s.io
    resources:
    - csistoragecapacities
    verbs:
    - get
    - list
    - watch

  # Copied from the system:volume-scheduler ClusterRole of the k8s version
  # matching the kube-scheduler binary we use.
  #
  # NOTE: These rules have not changed between 1.12 and 1.27.
  #
  # ref: https://github.com/kubernetes/kubernetes/blob/v1.27.0/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/testdata/cluster-roles.yaml#L1311-L1338
  - apiGroups:
    - ""
    resources:
    - persistentvolumes
    verbs:
    - get
    - list
    - patch
    - update
    - watch
  - apiGroups:
    - storage.k8s.io
    resources:
    - storageclasses
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - persistentvolumeclaims
    verbs:
    - get
    - list
    - patch
    - update
    - watch
---
# Source: jupyterhub/templates/scheduling/user-scheduler/rbac.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jupyterhub-user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: user-scheduler
    namespace: "jupyterhub"
roleRef:
  kind: ClusterRole
  name: jupyterhub-user-scheduler
  apiGroup: rbac.authorization.k8s.io
---
# Source: jupyterhub/templates/hub/rbac.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
rules:
  - apiGroups: [""]       # "" indicates the core API group
    resources: ["pods", "persistentvolumeclaims", "secrets", "services"]
    verbs: ["get", "watch", "list", "create", "delete"]
  - apiGroups: [""]       # "" indicates the core API group
    resources: ["events"]
    verbs: ["get", "watch", "list"]
---
# Source: jupyterhub/templates/hub/rbac.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: hub
    namespace: "jupyterhub"
roleRef:
  kind: Role
  name: hub
  apiGroup: rbac.authorization.k8s.io
---
# Source: jupyterhub/templates/hub/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/path: /hub/metrics
    prometheus.io/port: "8081"
spec:
  type: ClusterIP
  selector:
    component: hub
    app: jupyterhub
    release: jupyterhub
  ports:
    - name: hub
      port: 8081
      targetPort: http
---
# Source: jupyterhub/templates/proxy/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: proxy-api
  labels:
    component: proxy-api
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  selector:
    component: proxy
    app: jupyterhub
    release: jupyterhub
  ports:
    - port: 8001
      targetPort: api
---
# Source: jupyterhub/templates/proxy/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: proxy-public
  labels:
    component: proxy-public
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  selector:
    # This service will target the autohttps pod if autohttps is configured, and
    # the proxy pod if not. When autohttps is configured, the service proxy-http
    # will be around to target the proxy pod directly.
    component: proxy
    app: jupyterhub
    release: jupyterhub
  ports:
    - name: https
      port: 443
      # When HTTPS termination is handled outside our helm chart, pass traffic
      # coming in via this Service's port 443 to targeted pod's port meant for
      # HTTP traffic.
      targetPort: http
    - name: http
      port: 80
      targetPort: http
  type: ClusterIP
---
# Source: jupyterhub/templates/image-puller/daemonset-continuous.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: continuous-image-puller
  labels:
    component: continuous-image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  selector:
    matchLabels:
      component: continuous-image-puller
      app: jupyterhub
      release: jupyterhub
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 100%
  template:
    metadata:
      labels:
        component: continuous-image-puller
        app: jupyterhub
        release: jupyterhub
    spec:
      nodeSelector:
        cloud.google.com/gke-nodepool: ephemeral-pool
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: ephemeral
          operator: Equal
          value: "true"
      terminationGracePeriodSeconds: 0
      automountServiceAccountToken: false
      initContainers:
        - name: image-pull-singleuser
          image: jupyterhub/k8s-singleuser-sample:3.0.0-0.dev.git.6167.ha69d8ec6
          command:
            - /bin/sh
            - -c
            - echo "Pulling complete"
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
      containers:
        - name: pause
          image: registry.k8s.io/pause:3.9
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
---
# Source: jupyterhub/templates/hub/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hub
  labels:
    component: hub
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      component: hub
      app: jupyterhub
      release: jupyterhub
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        component: hub
        app: jupyterhub
        release: jupyterhub
        hub.jupyter.org/network-access-proxy-api: "true"
        hub.jupyter.org/network-access-proxy-http: "true"
        hub.jupyter.org/network-access-singleuser: "true"
      annotations:
        checksum/config-map: 021468e956a0ec0bedaa8d1f3b8a6230a097597924aedd1a7565c546aec10ced
        checksum/secret: 40a8b5c45fc2509efab6c2eb54448ba5fd9fe4b37852b0e0e943a8a13ae7682e
    spec:
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: core
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: core
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              preference:
                matchExpressions:
                  - key: hub.jupyter.org/node-purpose
                    operator: In
                    values: [core]
      volumes:
        - name: config
          configMap:
            name: hub
        - name: secret
          secret:
            secretName: hub
        - name: files
          secret:
            secretName: hub
            items:
              - key: "bind_url_config"
                path: "bind_url_config"
              - key: "custom_kube_spawner"
                path: "custom_kube_spawner"
              - key: "keycloak_authenticator"
                path: "keycloak_authenticator"
              - key: "keycloak_config"
                path: "keycloak_config"
              - key: "spawner_config"
                path: "spawner_config"
        - name: pvc
          persistentVolumeClaim:
            claimName: hub-db-dir
      serviceAccountName: hub
      securityContext:
        fsGroup: 1000
      containers:
        - name: hub
          image: jupyterhub/k8s-hub:3.0.0-0.dev.git.6167.h43af1c55
          args:
            - jupyterhub
            - --config
            - /usr/local/etc/jupyterhub/jupyterhub_config.py
            - --upgrade-db
          volumeMounts:
            - mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.py
              subPath: jupyterhub_config.py
              name: config
            - mountPath: /usr/local/etc/jupyterhub/z2jh.py
              subPath: z2jh.py
              name: config
            - mountPath: /usr/local/etc/jupyterhub/config/
              name: config
            - mountPath: /usr/local/etc/jupyterhub/secret/
              name: secret
            - mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/00_bind_url_config.py
              subPath: "bind_url_config"
              name: files
            - mountPath: /app/custom/custom_kube_spawner.py
              subPath: "custom_kube_spawner"
              name: files
            - mountPath: /app/custom/keycloak_authenticator.py
              subPath: "keycloak_authenticator"
              name: files
            - mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/01_keycloak_config.py
              subPath: "keycloak_config"
              name: files
            - mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/02_spawner_config.py
              subPath: "spawner_config"
              name: files
            - mountPath: /srv/jupyterhub
              name: pvc
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 1000
            runAsUser: 1000
          env:
            - name: PYTHONUNBUFFERED
              value: "1"
            - name: HELM_RELEASE_NAME
              value: "jupyterhub"
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: CONFIGPROXY_AUTH_TOKEN
              valueFrom:
                secretKeyRef:
                  name: hub
                  key: hub.config.ConfigurableHTTPProxy.auth_token
            - name: OAUTH2_AUTHORIZE_URL
              valueFrom:
                secretKeyRef:
                  key: OAUTH2_AUTHORIZE_URL
                  name: jupyterhub-oauth-keycloak
            - name: OAUTH2_TOKEN_URL
              valueFrom:
                secretKeyRef:
                  key: OAUTH2_TOKEN_URL
                  name: jupyterhub-oauth-keycloak
            - name: OAUTH2_USERDATA_URL
              valueFrom:
                secretKeyRef:
                  key: OAUTH2_USERDATA_URL
                  name: jupyterhub-oauth-keycloak
            - name: OAUTH_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  key: OAUTH_CLIENT_ID
                  name: jupyterhub-oauth-keycloak
            - name: OAUTH_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  key: OAUTH_CLIENT_SECRET
                  name: jupyterhub-oauth-keycloak
            - name: OAUTH_LOGOUT_REDIRECT_URL
              valueFrom:
                secretKeyRef:
                  key: OAUTH_LOGOUT_REDIRECT_URL
                  name: jupyterhub-oauth-keycloak
            - name: "PYTHONPATH"
              value: "/app/custom:$(PYTHONPATH)"
          ports:
            - name: http
              containerPort: 8081
          livenessProbe:
            initialDelaySeconds: 300
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 30
            httpGet:
              path: /hub/health
              port: http
          readinessProbe:
            initialDelaySeconds: 0
            periodSeconds: 2
            timeoutSeconds: 1
            failureThreshold: 1000
            httpGet:
              path: /hub/health
              port: http
---
# Source: jupyterhub/templates/proxy/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: proxy
  labels:
    component: proxy
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      component: proxy
      app: jupyterhub
      release: jupyterhub
  strategy:
    rollingUpdate: null
    type: Recreate
  template:
    metadata:
      labels:
        component: proxy
        app: jupyterhub
        release: jupyterhub
        hub.jupyter.org/network-access-hub: "true"
        hub.jupyter.org/network-access-singleuser: "true"
      annotations:
        # We want to restart proxy only if the auth token changes
        # Other changes to the hub config should not restart.
        # We truncate to 4 chars to avoid leaking auth token info,
        # since someone could brute force the hash to obtain the token
        #
        # Note that if auth_token has to be generated at random, it will be
        # generated at random here separately from being generated at random in
        # the k8s Secret template. This will cause this annotation to change to
        # match the k8s Secret during the first upgrade following an auth_token
        # was generated.
        checksum/auth-token: "bed3"
        checksum/proxy-secret: "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b"
    spec:
      terminationGracePeriodSeconds: 60
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: core
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: core
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              preference:
                matchExpressions:
                  - key: hub.jupyter.org/node-purpose
                    operator: In
                    values: [core]
      containers:
        - name: chp
          image: jupyterhub/configurable-http-proxy:4.5.5
          command:
            - configurable-http-proxy
            - "--ip="
            - "--api-ip="
            - --api-port=8001
            - --default-target=http://hub:$(HUB_SERVICE_PORT)
            - --error-target=http://hub:$(HUB_SERVICE_PORT)/hub/error
            - --port=8000
          env:
            - name: CONFIGPROXY_AUTH_TOKEN
              valueFrom:
                secretKeyRef:
                  # NOTE: References the chart managed k8s Secret even if
                  #       hub.existingSecret is specified to avoid using the
                  #       lookup function on the user managed k8s Secret.
                  name: hub
                  key: hub.config.ConfigurableHTTPProxy.auth_token
          ports:
            - name: http
              containerPort: 8000
            - name: api
              containerPort: 8001
          livenessProbe:
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 30
            httpGet:
              path: /_chp_healthz
              port: http
              scheme: HTTP
          readinessProbe:
            initialDelaySeconds: 0
            periodSeconds: 2
            timeoutSeconds: 1
            failureThreshold: 1000
            httpGet:
              path: /_chp_healthz
              port: http
              scheme: HTTP
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
---
# Source: jupyterhub/templates/scheduling/user-scheduler/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-scheduler
  labels:
    component: user-scheduler
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      component: user-scheduler
      app: jupyterhub
      release: jupyterhub
  template:
    metadata:
      labels:
        component: user-scheduler
        app: jupyterhub
        release: jupyterhub
      annotations:
        checksum/config-map: 7d823537f32745283a6b82a1546d9cc51cda0f7bbe592de3570dabaf1e837b6a
    spec:
      
      serviceAccountName: user-scheduler
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: core
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: core
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              preference:
                matchExpressions:
                  - key: hub.jupyter.org/node-purpose
                    operator: In
                    values: [core]
      volumes:
        - name: config
          configMap:
            name: user-scheduler
      containers:
        - name: kube-scheduler
          image: registry.k8s.io/kube-scheduler:v1.26.5
          command:
            - /usr/local/bin/kube-scheduler
            # NOTE: --authentication-skip-lookup=true is used to avoid a
            #       seemingly harmless error, if we need to not skip
            #       "authentication lookup" in the future, see the linked issue.
            #
            # ref: https://github.com/jupyterhub/zero-to-jupyterhub-k8s/issues/1894
            - --config=/etc/user-scheduler/config.yaml
            - --authentication-skip-lookup=true
            - --v=4
          volumeMounts:
            - mountPath: /etc/user-scheduler
              name: config
          livenessProbe:
            httpGet:
              path: /healthz
              scheme: HTTPS
              port: 10259
            initialDelaySeconds: 15
          readinessProbe:
            httpGet:
              path: /healthz
              scheme: HTTPS
              port: 10259
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
---
# Source: jupyterhub/templates/scheduling/user-placeholder/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: user-placeholder
  labels:
    component: user-placeholder
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
spec:
  podManagementPolicy: Parallel
  replicas: 0
  selector:
    matchLabels:
      component: user-placeholder
      app: jupyterhub
      release: jupyterhub
  serviceName: user-placeholder
  template:
    metadata:
      labels:
        component: user-placeholder
        app: jupyterhub
        release: jupyterhub
    spec:
      schedulerName: jupyterhub-user-scheduler
      nodeSelector:
        cloud.google.com/gke-nodepool: ephemeral-pool
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: ephemeral
          operator: Equal
          value: "true"
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              preference:
                matchExpressions:
                  - key: hub.jupyter.org/node-purpose
                    operator: In
                    values: [user]
      terminationGracePeriodSeconds: 0
      automountServiceAccountToken: false
      containers:
        - name: pause
          image: registry.k8s.io/pause:3.9
          resources:
            requests:
              memory: 1G
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
---
# Source: jupyterhub/templates/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: jupyterhub
  labels:
    component: ingress
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/backend-protocol: HTTP
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  ingressClassName: "nginx"
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: proxy-public
                port:
                  name: http
      host: "jupyterhub.prod.k8s.86labs.com"
  tls:
    - hosts:
      - jupyterhub.prod.k8s.86labs.com
      secretName: jupyterhub-prod-k8s-86labs-com
---
# Source: jupyterhub/templates/image-puller/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: hook-image-awaiter
  labels:
    component: image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
    hub.jupyter.org/deletable: "true"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
---
# Source: jupyterhub/templates/image-puller/rbac.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: hook-image-awaiter
  labels:
    component: image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
    hub.jupyter.org/deletable: "true"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
rules:
  - apiGroups: ["apps"]       # "" indicates the core API group
    resources: ["daemonsets"]
    verbs: ["get"]
---
# Source: jupyterhub/templates/image-puller/rbac.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: hook-image-awaiter
  labels:
    component: image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
    hub.jupyter.org/deletable: "true"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
subjects:
  - kind: ServiceAccount
    name: hook-image-awaiter
    namespace: "jupyterhub"
roleRef:
  kind: Role
  name: hook-image-awaiter
  apiGroup: rbac.authorization.k8s.io
---
# Source: jupyterhub/templates/image-puller/daemonset-hook.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: hook-image-puller
  labels:
    component: hook-image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
    hub.jupyter.org/deletable: "true"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "-10"
spec:
  selector:
    matchLabels:
      component: hook-image-puller
      app: jupyterhub
      release: jupyterhub
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 100%
  template:
    metadata:
      labels:
        component: hook-image-puller
        app: jupyterhub
        release: jupyterhub
    spec:
      nodeSelector:
        cloud.google.com/gke-nodepool: ephemeral-pool
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: user
        - effect: NoSchedule
          key: ephemeral
          operator: Equal
          value: "true"
      terminationGracePeriodSeconds: 0
      automountServiceAccountToken: false
      initContainers:
        - name: image-pull-singleuser
          image: jupyterhub/k8s-singleuser-sample:3.0.0-0.dev.git.6167.ha69d8ec6
          command:
            - /bin/sh
            - -c
            - echo "Pulling complete"
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
      containers:
        - name: pause
          image: registry.k8s.io/pause:3.9
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
---
# Source: jupyterhub/templates/image-puller/job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hook-image-awaiter
  labels:
    component: image-puller
    app: jupyterhub
    release: jupyterhub
    chart: jupyterhub-3.0.0-0.dev.git.6171.h0f4b2d0b
    heritage: Helm
    hub.jupyter.org/deletable: "true"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "10"
spec:
  template:
    # The hook-image-awaiter Job and hook-image-puller DaemonSet was
    # conditionally created based on this state:
    #
    # prePuller.hook.enabled=true
    # prePuller.hook.pullOnlyOnChanges=true
    # post-upgrade checksum != pre-upgrade checksum (of the hook-image-puller DaemonSet)
    # "e7e60844234e9c740573c1e6e8e13cca1968a61aafad4b86090ddb430207e943" != ""
    #
    metadata:
      labels:
        component: image-puller
        app: jupyterhub
        release: jupyterhub
    spec:
      restartPolicy: Never
      serviceAccountName: hook-image-awaiter
      tolerations:
        - effect: NoSchedule
          key: hub.jupyter.org/dedicated
          operator: Equal
          value: core
        - effect: NoSchedule
          key: hub.jupyter.org_dedicated
          operator: Equal
          value: core
      containers:
        - image: jupyterhub/k8s-image-awaiter:3.0.0-0.dev.git.6114.hc0d0b3b0
          name: hook-image-awaiter
          command:
            - /image-awaiter
            - -ca-path=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
            - -auth-token-path=/var/run/secrets/kubernetes.io/serviceaccount/token
            - -api-server-address=https://kubernetes.default.svc:$(KUBERNETES_SERVICE_PORT)
            - -namespace=jupyterhub
            - -daemonset=hook-image-puller
            - -pod-scheduling-wait-duration=10
          securityContext:
            allowPrivilegeEscalation: false
            runAsGroup: 65534
            runAsUser: 65534
