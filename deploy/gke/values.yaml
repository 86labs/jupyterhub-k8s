hub:
  extraConfig:
    00_bind_url_config: | 

  extraFiles:
    keycloak_authenticator:
      mountPath: /app/custom/keycloak_authenticator.py
    custom_kube_spawner:
      mountPath: /app/custom/custom_kube_spawner.py
    bind_url_config:
      mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/00_bind_url_config.py
      stringData: |
        c.JupyterHub.bind_url = 'https://jupyterhub.prod.k8s.86labs.com'
        c.JupyterHub.admin_access = True
    keycloak_config:
      mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/01_keycloak_config.py
      stringData: |
        from keycloak_authenticator import KeycloakAuthenticator
        c.JupyterHub.authenticator_class = KeycloakAuthenticator
    spawner_config:
      mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/02_spawner_config.py
      stringData: |
        from custom_kube_spawner import CustomKubeSpawner
        c.JupyterHub.spawner_class = CustomKubeSpawner

  extraEnv:
    PYTHONPATH: "/app/custom:$(PYTHONPATH)"
    OAUTH_CLIENT_ID:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH_CLIENT_ID
    OAUTH_CLIENT_SECRET:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH_CLIENT_SECRET
    OAUTH2_TOKEN_URL:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH2_TOKEN_URL
    OAUTH2_USERDATA_URL:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH2_USERDATA_URL
    OAUTH2_AUTHORIZE_URL:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH2_AUTHORIZE_URL
    OAUTH_LOGOUT_REDIRECT_URL:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-oauth-keycloak
          key: OAUTH_LOGOUT_REDIRECT_URL
scheduling:
  userScheduler:
    replicas: 1
proxy:
  service:
    type: ClusterIP
  https:
    enabled: true
    type: offload
singleuser:
  cloudMetadata:
    blockWithIptables: false
  extraEnv:
    JUPYTERHUB_SINGLEUSER_APP: "jupyter_server.serverapp.ServerApp"

  extraFiles:
    notebook_config:
      mountPath: "/usr/local/etc/jupyter/jupyter_server_config.py"
      stringData: |
        import boto3
        import requests
        from s3contents import S3ContentsManager
        sts_client = boto3.client('sts')
        def irsa_refresh(this_s3contents_instance):
            token_id_response = requests.get("http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=aws-trust-1",headers={"Metadata-Flavor":"Google"})
            sts_response = sts_client.assume_role_with_web_identity(
                                DurationSeconds=3600,
                                RoleArn='arn:aws:iam::469238831943:role/jupyterhub-gke-user',
                                RoleSessionName='jupyterhub',
                                WebIdentityToken=token_id_resp.text
                           )
            credentials = sts_response.get('Credentials')
            this_s3contents_instance._boto3_session_expiration = credentials.get('Expiration')
            this_s3contents_instance.log.info(f"boto3: {this_s3contents_instance._boto3_session_expiration}")
            _boto3_session = boto3.session.Session(aws_access_key_id=credentials.get('AccessKeyId'),
                                                   aws_secret_access_key=credentials.get('SecretAccessKey'),
                                                   aws_session_token=credentials.get('SessionToken'),
                                                   region_name='us-east-1')
            this_s3contents_instance.boto3_session = _boto3_session
        
        c.ServerApp.contents_manager_class = S3ContentsManager
        c.S3ContentsManager.init_s3_hook = irsa_refresh
        c.S3ContentsManager.bucket = "jupyterhub-86labs-com"
        c.S3ContentsManager.prefix = "notebooks/"

  nodeSelector:
    cloud.google.com/gke-nodepool: ephemeral-pool
  extraTolerations:
    - key: ephemeral
      value: "true"
      operator: Equal
      effect: "NoSchedule"
ingress:
  enabled: true
  ingressClassName: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true" # ssl termination is done before reaching this
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
  hosts:
  - jupyterhub.prod.k8s.86labs.com
  tls:
  - secretName: jupyterhub-prod-k8s-86labs-com
    hosts:
      - jupyterhub.prod.k8s.86labs.com